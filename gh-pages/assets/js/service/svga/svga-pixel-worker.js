class MemoryPool{constructor(){this.pools=new Map,this.maxPoolSize=50,this.minBufferSize=1024,this.maxBufferSize=52428800}getBuffer(e){if(e<=0||e>this.maxBufferSize)return new Uint8ClampedArray(e);const r=this._roundUpToPowerOfTwo(e),o=`Uint8ClampedArray_${r}`;if(this.pools.has(o)&&this.pools.get(o).length>0){return this.pools.get(o).pop()}return new Uint8ClampedArray(r)}recycleBuffer(e){if(!e||!e.buffer)return;const r=e.length;if(r<=0||r>this.maxBufferSize)return;const o=`Uint8ClampedArray_${this._roundUpToPowerOfTwo(r)}`;this.pools.has(o)||this.pools.set(o,[]);const s=this.pools.get(o);s.length<this.maxPoolSize&&(e.fill(0),s.push(e))}clear(){this.pools.forEach(e=>{e.length=0}),this.pools.clear()}_roundUpToPowerOfTwo(e){return e<=this.minBufferSize?this.minBufferSize:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e)}}const memoryPool=new MemoryPool,BLOCK_SIZE=128;async function handleProcessFrame(e){const r=e.frameData,o=e.alphaPosition,s=e.width,t=e.height,a=e.scaledWidth,n=e.scaledHeight,i=Math.floor(s/2),h=i*t*4,l=memoryPool.getBuffer(h),c=memoryPool.getBuffer(h),f=a*n*4,m=memoryPool.getBuffer(f),p=[];for(let e=0;e<t;e+=128)for(let r=0;r<i;r+=128)p.push({x:r,y:e,width:Math.min(128,i-r),height:Math.min(128,t-e)});let u=0;const d=p.length;await Promise.all(p.map(async h=>{await processFrameBlock(h,r,s,t,i,o,l,c,m,a,n),u++;const f=Math.round(u/d*100);f%10==0&&self.postMessage({id:e.id,type:"progress",progress:f})})),self.postMessage({id:e.id,type:"result",result:{processedData:m,width:a,height:n}},[m.buffer,l.buffer,c.buffer])}async function handleProcessFrames(e){const r=e.frames,o=e.alphaPosition,s=e.width,t=e.height,a=e.scaledWidth,n=e.scaledHeight;if(0===r.length)throw new Error("帧数组不能为空");const i=[],h=r.length;for(let l=0;l<h;l+=10){const c=Math.min(l+10,h),f=r.slice(l,c).map(async function(e,r){return await processSingleFrame(e,o,s,t,a,n)}),m=await Promise.all(f);i.push(...m);const p=Math.min(c,h),u=Math.round(p/h*100);u%20==0&&self.postMessage({id:e.id,type:"progress",progress:u})}const l=[];i.forEach(e=>{l.push(e.processedData.buffer)}),self.postMessage({id:e.id,type:"result",result:i},l)}async function processSingleFrame(e,r,o,s,t,a){const n=Math.floor(o/2),i=n*s*4,h=memoryPool.getBuffer(i),l=memoryPool.getBuffer(i),c=t*a*4,f=memoryPool.getBuffer(c),m=[];for(let e=0;e<s;e+=128)for(let r=0;r<n;r+=128)m.push({x:r,y:e,width:Math.min(128,n-r),height:Math.min(128,s-e)});return await Promise.all(m.map(i=>processFrameBlock(i,e,o,s,n,r,h,l,f,t,a))),{processedData:f,width:t,height:a}}function processFrameBlock(e,r,o,s,t,a,n,i,h,l,c){return new Promise(function(n){const i=e.x,f=e.y,m=e.width,p=e.height,u="right"===a?0:t,d="right"===a?t:0;for(let e=f;e<f+p;e++)for(let a=i;a<i+m;a++)try{const n=4*(e*o+(u+a)),i=4*(e*o+(d+a));if(n+3>=r.length||i+3>=r.length)continue;const f=r[n],m=r[n+1],p=r[n+2],g=r[i];let y=f,M=m,w=p;g>0&&(y=Math.min(255,Math.round(255*f/g)),M=Math.min(255,Math.round(255*m/g)),w=Math.min(255,Math.round(255*p/g)));const P=Math.round(a/t*l),B=Math.round(e/s*c);if(P<0||P>=l||B<0||B>=c)continue;const F=4*(B*l+P);h[F]=y,h[F+1]=M,h[F+2]=w,h[F+3]=g}catch(r){console.error("Error processing pixel at",a,",",e,":",r)}n()})}self.onmessage=function(e){var r=e.data;try{switch(r.type){case"processFrame":handleProcessFrame(r).catch(function(e){console.error("Error in handleProcessFrame:",e),self.postMessage({id:r.id,type:"error",error:e.message})});break;case"processFrames":handleProcessFrames(r).catch(function(e){console.error("Error in handleProcessFrames:",e),self.postMessage({id:r.id,type:"error",error:e.message})});break;case"clearMemory":memoryPool.clear(),self.postMessage({id:r.id,type:"success"});break;default:throw new Error("Unknown task type: "+r.type)}}catch(e){console.error("Error in message handler:",e),self.postMessage({id:r.id,type:"error",error:e.message})}};