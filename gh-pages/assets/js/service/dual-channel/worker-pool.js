!function(a){"use strict";window.MeeWoo=window.MeeWoo||{},window.MeeWoo.Services=window.MeeWoo.Services||{};class t{constructor(a){this.options=Object.assign({minWorkers:1,maxWorkers:navigator.hardwareConcurrency||4,maxTasksPerWorker:10,taskTimeout:6e4,idleTimeout:3e4,workerPath:null},a),this.workers=[],this.taskQueue=[],this.activeTasks=new Map,this.nextTaskId=1,this.stats={tasksProcessed:0,tasksFailed:0,peakWorkers:0,activeWorkers:0},this._initWorkers(),this._startIdleCheck()}_initWorkers(){for(let a=0;a<this.options.minWorkers;a++)this._createWorker()}_createWorker(){if(this.workers.length>=this.options.maxWorkers)return null;try{let a;a=this.options.workerPath?new Worker(this.options.workerPath):this._createInlineWorker();const t=this.workers.length+1,e={id:t,worker:a,status:"idle",taskCount:0,lastActivity:Date.now(),pendingTasks:0};return a.onmessage=a=>this._handleWorkerMessage(t,a),a.onerror=a=>this._handleWorkerError(t,a),this.workers.push(e),this.stats.activeWorkers++,this.stats.peakWorkers=Math.max(this.stats.peakWorkers,this.workers.length),console.log(`Worker ${t} created, total workers: ${this.workers.length}`),e}catch(a){return console.error("Failed to create worker:",a),null}}_createInlineWorker(){const a=`\n        // 内存池管理（Worker内部）\n        class MemoryPool {\n          constructor() {\n            this.pools = new Map();\n            this.maxPoolSize = 50;\n            this.minBufferSize = 1024;\n            this.maxBufferSize = 1024 * 1024 * 50; // 50MB\n          }\n\n          getBuffer(size) {\n            if (size <= 0 || size > this.maxBufferSize) {\n              return new Uint8ClampedArray(size);\n            }\n\n            const roundedSize = this._roundUpToPowerOfTwo(size);\n            const key = \`Uint8ClampedArray_${roundedSize}\`;\n\n            if (this.pools.has(key) && this.pools.get(key).length > 0) {\n              const pool = this.pools.get(key);\n              return pool.pop();\n            }\n\n            return new Uint8ClampedArray(roundedSize);\n          }\n\n          recycleBuffer(buffer) {\n            if (!buffer || !buffer.buffer) {\n              return;\n            }\n\n            const size = buffer.length;\n            if (size <= 0 || size > this.maxBufferSize) {\n              return;\n            }\n\n            const roundedSize = this._roundUpToPowerOfTwo(size);\n            const key = \`Uint8ClampedArray_${roundedSize}\`;\n\n            if (!this.pools.has(key)) {\n              this.pools.set(key, []);\n            }\n\n            const pool = this.pools.get(key);\n            if (pool.length < this.maxPoolSize) {\n              // 重置缓冲区\n              buffer.fill(0);\n              pool.push(buffer);\n            }\n          }\n\n          clear() {\n            this.pools.forEach(pool => {\n              pool.length = 0;\n            });\n            this.pools.clear();\n          }\n\n          _roundUpToPowerOfTwo(size) {\n            if (size <= this.minBufferSize) {\n              return this.minBufferSize;\n            }\n            size--;\n            size |= size >> 1;\n            size |= size >> 2;\n            size |= size >> 4;\n            size |= size >> 8;\n            size |= size >> 16;\n            size++;\n            return size;\n          }\n        }\n\n        // 全局内存池实例\n        const memoryPool = new MemoryPool();\n\n        // 分块大小配置\n        const BLOCK_SIZE = 128; // 128x128像素的块\n\n        // 检测SIMD支持 - 注意：JavaScript SIMD API已被废弃，这里仅作为预留\n        const hasSIMD = false; // 暂时禁用SIMD，因为JavaScript SIMD API已被废弃\n\n        // 处理消息\n        self.onmessage = function(e) {\n          var task = e.data;\n          \n          console.log('Worker received task:', task.type, 'Task ID:', task.id);\n          \n          try {\n            switch(task.type) {\n              case 'composeFrame':\n                console.log('Processing composeFrame task');\n                handleComposeFrame(task).catch(function(error) {\n                  console.error('Error in handleComposeFrame:', error);\n                  self.postMessage({ id: task.id, type: 'error', error: error.message });\n                });\n                break;\n              case 'composeFrames':\n                console.log('Processing composeFrames task, frame count:', task.data.frames.length);\n                handleComposeFrames(task).catch(function(error) {\n                  console.error('Error in handleComposeFrames:', error);\n                  self.postMessage({ id: task.id, type: 'error', error: error.message });\n                });\n                break;\n              case 'clearMemory':\n                console.log('Clearing memory pool');\n                memoryPool.clear();\n                self.postMessage({ id: task.id, type: 'success' });\n                break;\n              default:\n                throw new Error('Unknown task type: ' + task.type);\n            }\n          } catch(error) {\n            console.error('Error in message handler:', error);\n            self.postMessage({ id: task.id, type: 'error', error: error.message });\n          }\n        };\n\n        /**\n         * 处理单个帧的合成\n         */\n        async function handleComposeFrame(task) {\n          console.log('Starting handleComposeFrame, frame data length:', task.frame.data.length, 'width:', task.width, 'height:', task.height);\n          \n          var frameData = task.frame.data;\n          var width = task.width;\n          var height = task.height;\n          var mode = task.mode;\n          var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n          \n          // 计算双通道图像大小\n          var dualWidth = width * 2;\n          var dualHeight = height;\n          var dualDataSize = dualWidth * dualHeight * 4;\n          \n          console.log('Dual channel image size:', dualWidth, 'x', dualHeight, 'data size:', dualDataSize);\n          \n          // 内存优化：使用内存池分配缓冲区\n          var dualData = memoryPool.getBuffer(dualDataSize);\n          var blackBgData = memoryPool.getBuffer(dualDataSize);\n          \n          console.log('Memory allocated successfully');\n          \n          // 分块处理优化：将图像分成多个块并行处理\n          var blocks = [];\n          console.log('Generating blocks...');\n          for (var y = 0; y < height; y += BLOCK_SIZE) {\n            for (var x = 0; x < width; x += BLOCK_SIZE) {\n              blocks.push({\n                x: x,\n                y: y,\n                width: Math.min(BLOCK_SIZE, width - x),\n                height: Math.min(BLOCK_SIZE, height - y)\n              });\n            }\n          }\n          \n          console.log('Generated', blocks.length, 'blocks');\n          \n          // 并行处理所有块\n          console.log('Starting parallel processing of blocks...');\n          try {\n            var processedBlocks = 0;\n            var totalBlocks = blocks.length;\n            \n            await Promise.all(blocks.map(async block => {\n              await processBlock(\n                block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight\n              );\n              \n              // 报告进度\n              processedBlocks++;\n              var progress = Math.round((processedBlocks / totalBlocks) * 100);\n              \n              // 每5%的进度报告一次，避免过多的消息传递\n              if (progress % 5 === 0) {\n                self.postMessage({ id: task.id, type: 'progress', progress: progress });\n              }\n            }));\n            console.log('Block processing completed');\n          } catch (error) {\n            console.error('Error during block processing:', error);\n            throw error;\n          }\n          \n          // 使用transferable objects传递数据，减少内存复制\n          console.log('Posting result back to main thread');\n          self.postMessage({\n            id: task.id,\n            type: 'result',\n            result: {\n              blackBgData: blackBgData,\n              dualData: dualData,\n              width: dualWidth,\n              height: dualHeight\n            }\n          }, [blackBgData.buffer, dualData.buffer]);\n          \n          console.log('Result posted successfully');\n        }\n\n        /**\n         * 处理多个帧的合成\n         */\n        async function handleComposeFrames(task) {\n          console.log('Starting handleComposeFrames, frame count:', task.data.frames.length);\n          \n          var data = task.data;\n          var frames = data.frames;\n          var mode = data.mode;\n          var frameCount = frames.length;\n          \n          if (frameCount === 0) {\n            throw new Error('帧数组不能为空');\n          }\n          \n          console.log('First frame size:', frames[0].width, 'x', frames[0].height);\n          \n          var results = [];\n          var width = frames[0].width;\n          var height = frames[0].height;\n          var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n          var dualWidth = width * 2;\n          var dualDataSize = dualWidth * height * 4;\n          \n          console.log('Dual channel image size per frame:', dualWidth, 'x', height, 'data size:', dualDataSize);\n          \n          // 分批处理配置\n          const BATCH_SIZE = 20; // 每批处理20帧\n          console.log('Worker使用分批处理，每批', BATCH_SIZE, '帧');\n          \n          // 分批处理帧\n          for (let batchStart = 0; batchStart < frameCount; batchStart += BATCH_SIZE) {\n            const batchEnd = Math.min(batchStart + BATCH_SIZE, frameCount);\n            const batchFrames = frames.slice(batchStart, batchEnd);\n            const batchSize = batchFrames.length;\n            console.log('Worker处理批次:', batchStart, '-', batchEnd, '共', batchSize, '帧');\n            \n            // 并行处理当前批次\n            var framePromises = batchFrames.map(async function(frameData, index) {\n              const frameIndex = batchStart + index;\n              console.log('Processing frame', frameIndex + 1, 'of', frameCount);\n              \n              // 内存优化：使用内存池分配缓冲区\n              var dualData = memoryPool.getBuffer(dualDataSize);\n              var blackBgData = memoryPool.getBuffer(dualDataSize);\n              \n              console.log('Memory allocated for frame', frameIndex);\n              \n              // 分块处理优化：将图像分成多个块并行处理\n              var blocks = [];\n              for (var y = 0; y < height; y += BLOCK_SIZE) {\n                for (var x = 0; x < width; x += BLOCK_SIZE) {\n                  blocks.push({\n                    x: x,\n                    y: y,\n                    width: Math.min(BLOCK_SIZE, width - x),\n                    height: Math.min(BLOCK_SIZE, height - y)\n                  });\n                }\n              }\n              \n              console.log('Generated', blocks.length, 'blocks for frame', frameIndex);\n              \n              // 并行处理所有块\n              try {\n                await Promise.all(blocks.map(block => processBlock(\n                  block, frameData.data, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight\n                )));\n                console.log('Frame', frameIndex, 'processing completed');\n              } catch (error) {\n                console.error('Error processing frame', frameIndex, ':', error);\n                // 返回空结果，让主线程处理\n                return null;\n              }\n              \n              return {\n                blackBgData: blackBgData,\n                width: dualWidth,\n                height: height\n              };\n            });\n            \n            // 等待当前批次处理完成\n            console.log('Waiting for batch frames to complete...');\n            try {\n              const batchResults = await Promise.all(framePromises);\n              \n              // 过滤掉空结果\n              const validResults = batchResults.filter(result => result !== null);\n              results.push(...validResults);\n              \n              console.log('Batch processed successfully, valid results:', validResults.length);\n              \n              // 报告批次进度\n              const processedFrames = Math.min(batchEnd, frameCount);\n              var progress = Math.round((processedFrames / frameCount) * 100);\n              \n              // 每5%的进度报告一次\n              if (progress % 5 === 0) {\n                self.postMessage({ id: task.id, type: 'progress', progress: progress });\n              }\n              \n              // 强制垃圾回收\n              if (typeof gc === 'function') {\n                gc();\n              }\n              console.log('Batch completed, total results so far:', results.length);\n            } catch (error) {\n              console.error('Error in batch processing:', error);\n              // 继续处理下一批\n              continue;\n            }\n          }\n          \n          // 提取transferable objects\n          var transferables = [];\n          results.forEach(result => {\n            transferables.push(result.blackBgData.buffer);\n          });\n          \n          console.log('Extracted transferable objects, count:', transferables.length);\n          \n          // 使用transferable objects传递数据，减少内存复制\n          console.log('Posting results back to main thread');\n          self.postMessage({\n            id: task.id,\n            type: 'result',\n            result: results\n          }, transferables);\n          \n          console.log('Results posted successfully, total frames processed:', results.length);\n        }\n\n        /**\n         * 处理单个图像块\n         */\n        function processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight) {\n          return new Promise(function(resolve) {\n            var startX = block.x;\n            var startY = block.y;\n            var blockWidth = block.width;\n            var blockHeight = block.height;\n            \n            // 算法优化：减少循环内的计算\n            var inv255 = 1 / 255;\n            \n            try {\n              // 使用SIMD优化处理像素\n              if (hasSIMD) {\n                processBlockWithSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n              } else {\n                // 回退到普通处理方式\n                processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n              }\n              \n              resolve();\n            } catch (error) {\n              console.error('Error processing block:', error, 'at position:', startX, ',', startY);\n              resolve(); // 即使出错也继续处理\n            }\n          });\n        }\n\n        /**\n         * 使用SIMD指令处理图像块\n         */\n        function processBlockWithSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n          var startX = block.x;\n          var startY = block.y;\n          var blockWidth = block.width;\n          var blockHeight = block.height;\n          \n          // 预计算SIMD常量\n          var simd255 = SIMD.int32x4.splat(255);\n          var simd0 = SIMD.int32x4.splat(0);\n          var simdAlphaFactor = SIMD.float32x4.splat(255 * inv255);\n          \n          // 处理块内的每个像素（每次处理4个像素）\n          for (var y = startY; y < startY + blockHeight; y++) {\n            for (var x = startX; x < startX + blockWidth; x += 4) {\n              // 计算剩余像素数\n              var pixelsToProcess = Math.min(4, startX + blockWidth - x);\n              \n              if (pixelsToProcess === 4) {\n                // 处理4个像素\n                process4PixelsWithSIMD(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255, simd255, simd0, simdAlphaFactor);\n              } else {\n                // 处理剩余的1-3个像素\n                for (var i = 0; i < pixelsToProcess; i++) {\n                  var currentX = x + i;\n                  processSinglePixel(currentX, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n                }\n              }\n            }\n          }\n        }\n\n        /**\n         * 使用SIMD指令并行处理4个像素\n         */\n        function process4PixelsWithSIMD(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255, simd255, simd0, simdAlphaFactor) {\n          // 计算4个像素的索引\n          var pixelIndices = [\n            y * width + x,\n            y * width + x + 1,\n            y * width + x + 2,\n            y * width + x + 3\n          ];\n          \n          var frameIndices = pixelIndices.map(idx => idx * 4);\n          \n          // 加载4个像素的RGBA数据\n          var rValues = SIMD.int32x4(frameData[frameIndices[0]], frameData[frameIndices[1]], frameData[frameIndices[2]], frameData[frameIndices[3]]);\n          var gValues = SIMD.int32x4(frameData[frameIndices[0] + 1], frameData[frameIndices[1] + 1], frameData[frameIndices[2] + 1], frameData[frameIndices[3] + 1]);\n          var bValues = SIMD.int32x4(frameData[frameIndices[0] + 2], frameData[frameIndices[1] + 2], frameData[frameIndices[2] + 2], frameData[frameIndices[3] + 2]);\n          var aValues = SIMD.int32x4(frameData[frameIndices[0] + 3], frameData[frameIndices[1] + 3], frameData[frameIndices[2] + 3], frameData[frameIndices[3] + 3]);\n          \n          // 反预乘Alpha\n          var finalR = rValues;\n          var finalG = gValues;\n          var finalB = bValues;\n          \n          // 处理Alpha值不为255的情况\n          for (var i = 0; i < 4; i++) {\n            var alpha = frameData[frameIndices[i] + 3];\n            if (alpha > 0 && alpha < 255) {\n              var alphaFactor = 255 * inv255;\n              finalR = SIMD.int32x4.replaceLane(finalR, i, Math.min(255, Math.round(frameData[frameIndices[i]] * alphaFactor)));\n              finalG = SIMD.int32x4.replaceLane(finalG, i, Math.min(255, Math.round(frameData[frameIndices[i] + 1] * alphaFactor)));\n              finalB = SIMD.int32x4.replaceLane(finalB, i, Math.min(255, Math.round(frameData[frameIndices[i] + 2] * alphaFactor)));\n            } else if (alpha === 0) {\n              finalR = SIMD.int32x4.replaceLane(finalR, i, 0);\n              finalG = SIMD.int32x4.replaceLane(finalG, i, 0);\n              finalB = SIMD.int32x4.replaceLane(finalB, i, 0);\n            }\n          }\n          \n          // 处理每个像素\n          for (var i = 0; i < 4; i++) {\n            var currentX = x + i;\n            var pixelIndex = y * width + currentX;\n            var frameIdx = pixelIndex * 4;\n            \n            var r = SIMD.int32x4.extractLane(finalR, i);\n            var g = SIMD.int32x4.extractLane(finalG, i);\n            var b = SIMD.int32x4.extractLane(finalB, i);\n            var a = frameData[frameIdx + 3];\n            \n            // 计算位置\n            var leftIdx = (y * dualWidth + currentX) * 4;\n            var rightIdx = (y * dualWidth + currentX + width) * 4;\n\n            if (isColorLeftAlphaRight) {\n              dualData[leftIdx + 0] = r;\n              dualData[leftIdx + 1] = g;\n              dualData[leftIdx + 2] = b;\n              dualData[leftIdx + 3] = a;\n              dualData[rightIdx + 0] = a;\n              dualData[rightIdx + 1] = a;\n              dualData[rightIdx + 2] = a;\n              dualData[rightIdx + 3] = 255;\n            } else {\n              dualData[leftIdx + 0] = a;\n              dualData[leftIdx + 1] = a;\n              dualData[leftIdx + 2] = a;\n              dualData[leftIdx + 3] = 255;\n              dualData[rightIdx + 0] = r;\n              dualData[rightIdx + 1] = g;\n              dualData[rightIdx + 2] = b;\n              dualData[rightIdx + 3] = a;\n            }\n\n            // 合成黑底\n            // 左侧通道\n            var pixelAlphaLeft = dualData[leftIdx + 3];\n            if (pixelAlphaLeft === 255) {\n              blackBgData[leftIdx + 0] = dualData[leftIdx + 0];\n              blackBgData[leftIdx + 1] = dualData[leftIdx + 1];\n              blackBgData[leftIdx + 2] = dualData[leftIdx + 2];\n            } else if (pixelAlphaLeft === 0) {\n              blackBgData[leftIdx + 0] = 0;\n              blackBgData[leftIdx + 1] = 0;\n              blackBgData[leftIdx + 2] = 0;\n            } else {\n              var alphaFactorLeft = pixelAlphaLeft * inv255;\n              blackBgData[leftIdx + 0] = Math.round(dualData[leftIdx + 0] * alphaFactorLeft);\n              blackBgData[leftIdx + 1] = Math.round(dualData[leftIdx + 1] * alphaFactorLeft);\n              blackBgData[leftIdx + 2] = Math.round(dualData[leftIdx + 2] * alphaFactorLeft);\n            }\n            blackBgData[leftIdx + 3] = 255;\n\n            // 右侧通道\n            var pixelAlphaRight = dualData[rightIdx + 3];\n            if (pixelAlphaRight === 255) {\n              blackBgData[rightIdx + 0] = dualData[rightIdx + 0];\n              blackBgData[rightIdx + 1] = dualData[rightIdx + 1];\n              blackBgData[rightIdx + 2] = dualData[rightIdx + 2];\n            } else if (pixelAlphaRight === 0) {\n              blackBgData[rightIdx + 0] = 0;\n              blackBgData[rightIdx + 1] = 0;\n              blackBgData[rightIdx + 2] = 0;\n            } else {\n              var alphaFactorRight = pixelAlphaRight * inv255;\n              blackBgData[rightIdx + 0] = Math.round(dualData[rightIdx + 0] * alphaFactorRight);\n              blackBgData[rightIdx + 1] = Math.round(dualData[rightIdx + 1] * alphaFactorRight);\n              blackBgData[rightIdx + 2] = Math.round(dualData[rightIdx + 2] * alphaFactorRight);\n            }\n            blackBgData[rightIdx + 3] = 255;\n          }\n        }\n\n        /**\n         * 不使用SIMD指令处理图像块\n         */\n        function processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n          var startX = block.x;\n          var startY = block.y;\n          var blockWidth = block.width;\n          var blockHeight = block.height;\n          \n          // 处理块内的每个像素\n          var pixelCount = 0;\n          for (var y = startY; y < startY + blockHeight; y++) {\n            for (var x = startX; x < startX + blockWidth; x++) {\n              try {\n                processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n                pixelCount++;\n              } catch (error) {\n                console.error('Error processing pixel at', x, ',', y, ':', error);\n              }\n            }\n          }\n        }\n\n        /**\n         * 处理单个像素\n         */\n        function processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n          // 算法优化：使用位运算和数学优化计算索引\n          var pixelIndex = y * width + x;\n          var frameIdx = pixelIndex * 4;\n          \n          // 检查索引是否有效\n          if (frameIdx + 3 >= frameData.length) {\n            console.error('Invalid frame index:', frameIdx, 'for frame data length:', frameData.length);\n            return;\n          }\n          \n          var r = frameData[frameIdx + 0];\n          var g = frameData[frameIdx + 1];\n          var b = frameData[frameIdx + 2];\n          var a = frameData[frameIdx + 3];\n\n          // 反预乘Alpha\n          var finalR = r, finalG = g, finalB = b;\n          if (a > 0) {\n            if (a < 255) {\n              // 算法优化：使用乘法代替除法\n              var alphaFactor = 255 * inv255;\n              finalR = Math.min(255, Math.round(r * alphaFactor));\n              finalG = Math.min(255, Math.round(g * alphaFactor));\n              finalB = Math.min(255, Math.round(b * alphaFactor));\n            }\n          } else {\n            finalR = 0; finalG = 0; finalB = 0;\n          }\n\n          // 计算位置\n          var leftIdx = (y * dualWidth + x) * 4;\n          var rightIdx = (y * dualWidth + x + width) * 4;\n\n          // 检查索引是否有效\n          if (leftIdx + 3 >= dualData.length || rightIdx + 3 >= dualData.length) {\n            console.error('Invalid dual data index:', leftIdx, 'or', rightIdx, 'for dual data length:', dualData.length);\n            return;\n          }\n\n          if (isColorLeftAlphaRight) {\n            dualData[leftIdx + 0] = finalR;\n            dualData[leftIdx + 1] = finalG;\n            dualData[leftIdx + 2] = finalB;\n            dualData[leftIdx + 3] = a;\n            dualData[rightIdx + 0] = a;\n            dualData[rightIdx + 1] = a;\n            dualData[rightIdx + 2] = a;\n            dualData[rightIdx + 3] = 255;\n          } else {\n            dualData[leftIdx + 0] = a;\n            dualData[leftIdx + 1] = a;\n            dualData[leftIdx + 2] = a;\n            dualData[leftIdx + 3] = 255;\n            dualData[rightIdx + 0] = finalR;\n            dualData[rightIdx + 1] = finalG;\n            dualData[rightIdx + 2] = finalB;\n            dualData[rightIdx + 3] = a;\n          }\n\n          // 合成黑底\n          // 左侧通道\n          var pixelAlphaLeft = dualData[leftIdx + 3];\n          if (pixelAlphaLeft === 255) {\n            blackBgData[leftIdx + 0] = dualData[leftIdx + 0];\n            blackBgData[leftIdx + 1] = dualData[leftIdx + 1];\n            blackBgData[leftIdx + 2] = dualData[leftIdx + 2];\n          } else if (pixelAlphaLeft === 0) {\n            blackBgData[leftIdx + 0] = 0;\n            blackBgData[leftIdx + 1] = 0;\n            blackBgData[leftIdx + 2] = 0;\n          } else {\n            // 半透明像素：与黑底混合\n            var alphaFactorLeft = pixelAlphaLeft * inv255;\n            blackBgData[leftIdx + 0] = Math.round(dualData[leftIdx + 0] * alphaFactorLeft);\n            blackBgData[leftIdx + 1] = Math.round(dualData[leftIdx + 1] * alphaFactorLeft);\n            blackBgData[leftIdx + 2] = Math.round(dualData[leftIdx + 2] * alphaFactorLeft);\n          }\n          blackBgData[leftIdx + 3] = 255;\n\n          // 右侧通道\n          var pixelAlphaRight = dualData[rightIdx + 3];\n          if (pixelAlphaRight === 255) {\n            blackBgData[rightIdx + 0] = dualData[rightIdx + 0];\n            blackBgData[rightIdx + 1] = dualData[rightIdx + 1];\n            blackBgData[rightIdx + 2] = dualData[rightIdx + 2];\n          } else if (pixelAlphaRight === 0) {\n            blackBgData[rightIdx + 0] = 0;\n            blackBgData[rightIdx + 1] = 0;\n            blackBgData[rightIdx + 2] = 0;\n          } else {\n            // 半透明像素：与黑底混合\n            var alphaFactorRight = pixelAlphaRight * inv255;\n            blackBgData[rightIdx + 0] = Math.round(dualData[rightIdx + 0] * alphaFactorRight);\n            blackBgData[rightIdx + 1] = Math.round(dualData[rightIdx + 1] * alphaFactorRight);\n            blackBgData[rightIdx + 2] = Math.round(dualData[rightIdx + 2] * alphaFactorRight);\n          }\n          blackBgData[rightIdx + 3] = 255;\n        }\n      `,t=new Blob([a],{type:"application/javascript"}),e=URL.createObjectURL(t);return new Worker(e)}_handleWorkerMessage(a,t){const e=t.data,n=e.id;if(this.activeTasks.has(n)){const t=this.activeTasks.get(n);if("progress"===e.type)t.onProgress&&t.onProgress(e.progress/100);else{const r=this.workers.find(t=>t.id===a);r&&(r.status="idle",r.taskCount++,r.lastActivity=Date.now(),r.pendingTasks--),this.activeTasks.delete(n),this.stats.tasksProcessed++,"error"===e.type?(this.stats.tasksFailed++,t.reject(new Error(e.error))):t.resolve(e.result),this._processTaskQueue()}}}_handleWorkerError(a,t){console.error(`Worker ${a} error:`,t);for(const[e,n]of this.activeTasks.entries())n.workerId===a&&(this.activeTasks.delete(e),this.stats.tasksFailed++,n.reject(new Error(`Worker error: ${t.message}`)));this._destroyWorker(a),this._createWorker(),this._processTaskQueue()}_destroyWorker(a){const t=this.workers.findIndex(t=>t.id===a);if(-1===t)return;const e=this.workers[t];try{e.worker.terminate(),console.log(`Worker ${a} terminated`)}catch(t){console.error(`Error terminating worker ${a}:`,t)}this.workers.splice(t,1),this.stats.activeWorkers--}_processTaskQueue(){if(0===this.taskQueue.length)return;let a=this.workers.find(a=>"idle"===a.status&&a.pendingTasks<this.options.maxTasksPerWorker);if(!a&&this.workers.length<this.options.maxWorkers&&(a=this._createWorker()),a){const t=this.taskQueue.shift();this._assignTaskToWorker(a,t)}}_assignTaskToWorker(a,t){a.status="busy",a.pendingTasks++,a.lastActivity=Date.now();const e=t.id;this.activeTasks.set(e,{...t,workerId:a.id,startTime:Date.now()});try{a.worker.postMessage({id:e,type:t.type,...t.data})}catch(n){console.error(`Error sending task to worker ${a.id}:`,n),a.status="idle",a.pendingTasks--,this.activeTasks.delete(e),this.stats.tasksFailed++,t.reject(new Error(`Failed to send task: ${n.message}`)),this._processTaskQueue()}}_startIdleCheck(){setInterval(()=>{this._checkIdleWorkers()},5e3)}_checkIdleWorkers(){const a=Date.now(),t=[];for(const e of this.workers)"idle"===e.status&&e.taskCount>0&&a-e.lastActivity>this.options.idleTimeout&&this.workers.length>this.options.minWorkers&&t.push(e.id);for(const a of t)this._destroyWorker(a)}submitTask(a,t,e={}){const n=this.nextTaskId++,r=e.priority||5;return new Promise((s,o)=>{const i={id:n,type:a,data:t,priority:r,onProgress:e.onProgress||null,resolve:s,reject:o,submittedAt:Date.now()};this._insertTaskByPriority(i),this._processTaskQueue()})}_insertTaskByPriority(a){let t=!1;for(let e=0;e<this.taskQueue.length;e++)if(a.priority>this.taskQueue[e].priority){this.taskQueue.splice(e,0,a),t=!0;break}t||this.taskQueue.push(a)}submitTasks(a){return Promise.all(a.map(a=>this.submitTask(a.type,a.data,a.options)))}clearTaskQueue(){for(const a of this.taskQueue)a.reject(new Error("Task queue cleared"));this.taskQueue=[]}shutdown(){this.clearTaskQueue();for(const a of this.workers)try{a.worker.terminate()}catch(t){console.error(`Error terminating worker ${a.id}:`,t)}this.workers=[],this.activeTasks.clear(),this.stats.activeWorkers=0,console.log("Worker pool shutdown completed")}getStatus(){return{workers:this.workers.map(a=>({id:a.id,status:a.status,taskCount:a.taskCount,pendingTasks:a.pendingTasks,lastActivity:a.lastActivity})),queueSize:this.taskQueue.length,activeTasks:this.activeTasks.size,stats:{...this.stats}}}getStats(){return{...this.stats}}resetStats(){this.stats={tasksProcessed:0,tasksFailed:0,peakWorkers:this.stats.peakWorkers,activeWorkers:this.stats.activeWorkers}}}const e=new t;window.MeeWoo.Services.WorkerPool=e,"undefined"!=typeof module&&module.exports?module.exports=t:a.WorkerPool=t}("undefined"!=typeof window?window:this);