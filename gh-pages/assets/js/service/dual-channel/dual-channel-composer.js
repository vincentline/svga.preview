!function(e){"use strict";if(window.MeeWoo=window.MeeWoo||{},window.MeeWoo.Services=window.MeeWoo.Services||{},"function"==typeof require)try{require("./memory-pool.js"),require("./worker-pool.js"),require("./wasm/wasm-loader.js")}catch(e){}var a={defaults:{mode:"color-left-alpha-right",jpegQuality:.6,format:"jpeg",workerPath:"assets/js/service/dual-channel/dual-channel-worker.js",memoryPool:{enabled:!0,maxPoolSize:100,clearInterval:6e4},workerPool:{enabled:!0,minWorkers:1,maxWorkers:navigator.hardwareConcurrency||4,maxTasksPerWorker:10,taskTimeout:6e4,idleTimeout:3e4},wasm:{enabled:!0,modulePath:"assets/js/service/dual-channel/wasm/dual-channel-core.wasm",fallbackToJS:!0,useSIMD:!0}},_worker:null,_taskId:0,_memoryPool:null,_memoryClearInterval:null,_workerPool:null,_wasmLoader:null,_initWorker:function(){if(!this._worker)try{console.log("开始初始化Web Worker");const e=new Blob(["\n// 分块大小配置\nconst BLOCK_SIZE = 128;\n\n// 检测SIMD支持\nconst hasSIMD = false;\n\n// 处理消息\nself.onmessage = function(e) {\n  var task = e.data;\n  console.log('Worker received task:', task.type, 'Task ID:', task.id);\n  \n  try {\n    switch(task.type) {\n      case 'composeFrame':\n        console.log('Processing composeFrame task');\n        handleComposeFrame(task).catch(function(error) {\n          console.error('Error in handleComposeFrame:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n\n        break;\n      case 'composeFrames':\n        console.log('Processing composeFrames task, frame count:', task.data.frames.length);\n        handleComposeFrames(task).catch(function(error) {\n          console.error('Error in handleComposeFrames:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n        break;\n      default:\n        throw new Error('Unknown task type: ' + task.type);\n    }\n  } catch(error) {\n    console.error('Error in message handler:', error);\n    self.postMessage({ id: task.id, type: 'error', error: error.message });\n  }\n};\n\nasync function handleComposeFrame(task) {\n  console.log('Starting handleComposeFrame, frame data length:', task.frame.data.length, 'width:', task.width, 'height:', task.height);\n  \n  var frameData = task.frame.data;\n  var width = task.width;\n  var height = task.height;\n  var mode = task.mode;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  \n  var dualWidth = width * 2;\n  var dualHeight = height;\n  var dualDataSize = dualWidth * dualHeight * 4;\n  \n  console.log('Dual channel image size:', dualWidth, 'x', dualHeight, 'data size:', dualDataSize);\n  \n  var dualData = new Uint8ClampedArray(dualDataSize);\n  var blackBgData = new Uint8ClampedArray(dualDataSize);\n  \n  console.log('Memory allocated successfully');\n  \n  var blocks = [];\n  console.log('Generating blocks...');\n  for (var y = 0; y < height; y += BLOCK_SIZE) {\n    for (var x = 0; x < width; x += BLOCK_SIZE) {\n      blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n    }\n  }\n  \n  console.log('Generated', blocks.length, 'blocks');\n  \n  console.log('Starting parallel processing of blocks...');\n  try {\n    var processedBlocks = 0;\n    var totalBlocks = blocks.length;\n    \n    await Promise.all(blocks.map(async block => {\n      await processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight);\n      \n      processedBlocks++;\n      var progress = Math.round((processedBlocks / totalBlocks) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n    }));\n    console.log('Block processing completed');\n  } catch (error) {\n    console.error('Error during block processing:', error);\n    throw error;\n  }\n  \n  console.log('Posting result back to main thread');\n  self.postMessage({ id: task.id, type: 'result', result: { blackBgData: blackBgData, dualData: dualData, width: dualWidth, height: dualHeight } }, [blackBgData.buffer, dualData.buffer]);\n  console.log('Result posted successfully');\n}\n\nasync function handleComposeFrames(task) {\n  console.log('Starting handleComposeFrames, frame count:', task.data.frames.length);\n  \n  var data = task.data;\n  var frames = data.frames;\n  var mode = data.mode;\n  var frameCount = frames.length;\n  \n  if (frameCount === 0) {\n    throw new Error('帧数组不能为空');\n  }\n  \n  console.log('First frame size:', frames[0].width, 'x', frames[0].height);\n  \n  var results = [];\n  var width = frames[0].width;\n  var height = frames[0].height;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  var dualWidth = width * 2;\n  var dualDataSize = dualWidth * height * 4;\n  \n  console.log('Dual channel image size per frame:', dualWidth, 'x', height, 'data size:', dualDataSize);\n  \n  const BATCH_SIZE = 20;\n  console.log('Worker使用分批处理，每批', BATCH_SIZE, '帧');\n  \n  for (let batchStart = 0; batchStart < frameCount; batchStart += BATCH_SIZE) {\n    const batchEnd = Math.min(batchStart + BATCH_SIZE, frameCount);\n    const batchFrames = frames.slice(batchStart, batchEnd);\n    const batchSize = batchFrames.length;\n    console.log('Worker处理批次:', batchStart, '-', batchEnd, '共', batchSize, '帧');\n    \n    var framePromises = batchFrames.map(async function(frameData, index) {\n      const frameIndex = batchStart + index;\n      console.log('Processing frame', frameIndex + 1, 'of', frameCount);\n      \n      var dualData = new Uint8ClampedArray(dualDataSize);\n      var blackBgData = new Uint8ClampedArray(dualDataSize);\n      \n      console.log('Memory allocated for frame', frameIndex);\n      \n      var blocks = [];\n      for (var y = 0; y < height; y += BLOCK_SIZE) {\n        for (var x = 0; x < width; x += BLOCK_SIZE) {\n          blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n        }\n      }\n      \n      console.log('Generated', blocks.length, 'blocks for frame', frameIndex);\n      \n      try {\n        await Promise.all(blocks.map(block => processBlock(block, frameData.data, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight)));\n        console.log('Frame', frameIndex, 'processing completed');\n      } catch (error) {\n        console.error('Error processing frame', frameIndex, ':', error);\n        return null;\n      }\n      \n      return { blackBgData: blackBgData, width: dualWidth, height: height };\n    });\n    \n    console.log('Waiting for batch frames to complete...');\n    try {\n      const batchResults = await Promise.all(framePromises);\n      \n      const validResults = batchResults.filter(result => result !== null);\n      results.push(...validResults);\n      \n      console.log('Batch processed successfully, valid results:', validResults.length);\n      \n      const processedFrames = Math.min(batchEnd, frameCount);\n      var progress = Math.round((processedFrames / frameCount) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n      \n      console.log('Batch completed, total results so far:', results.length);\n    } catch (error) {\n      console.error('Error in batch processing:', error);\n      continue;\n    }\n  }\n  \n  var transferables = [];\n  results.forEach(result => {\n    transferables.push(result.blackBgData.buffer);\n  });\n  \n  console.log('Extracted transferable objects, count:', transferables.length);\n  \n  console.log('Posting results back to main thread');\n  self.postMessage({ id: task.id, type: 'result', result: results }, transferables);\n  \n  console.log('Results posted successfully, total frames processed:', results.length);\n}\n\nfunction processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight) {\n  return new Promise(function(resolve) {\n    var startX = block.x;\n    var startY = block.y;\n    var blockWidth = block.width;\n    var blockHeight = block.height;\n    \n    console.log('Processing block:', startX, ',', startY, 'size:', blockWidth, 'x', blockHeight);\n    \n    var inv255 = 1 / 255;\n    \n    try {\n      processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n      \n      console.log('Block processing completed:', startX, ',', startY);\n      resolve();\n    } catch (error) {\n      console.error('Error processing block:', error, 'at position:', startX, ',', startY);\n      resolve();\n    }\n  });\n}\n\nfunction processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var startX = block.x;\n  var startY = block.y;\n  var blockWidth = block.width;\n  var blockHeight = block.height;\n  \n  console.log('Processing block without SIMD:', startX, ',', startY, 'size:', blockWidth, 'x', blockHeight);\n  \n  var pixelCount = 0;\n  for (var y = startY; y < startY + blockHeight; y++) {\n    for (var x = startX; x < startX + blockWidth; x++) {\n      try {\n        processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n        pixelCount++;\n      } catch (error) {\n        console.error('Error processing pixel at', x, ',', y, ':', error);\n      }\n    }\n  }\n  \n  console.log('Block processing completed, total pixels:', pixelCount);\n}\n\nfunction processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var pixelIndex = y * width + x;\n  var frameIdx = pixelIndex * 4;\n  \n  if (frameIdx + 3 >= frameData.length) {\n    console.error('Invalid frame index:', frameIdx, 'for frame data length:', frameData.length);\n    return;\n  }\n  \n  var r = frameData[frameIdx + 0];\n  var g = frameData[frameIdx + 1];\n  var b = frameData[frameIdx + 2];\n  var a = frameData[frameIdx + 3];\n\n  var finalR = r, finalG = g, finalB = b;\n  if (a > 0) {\n    if (a < 255) {\n      var alphaFactor = 255 * inv255;\n      finalR = Math.min(255, Math.round(r * alphaFactor));\n      finalG = Math.min(255, Math.round(g * alphaFactor));\n      finalB = Math.min(255, Math.round(b * alphaFactor));\n    }\n  } else {\n    finalR = 0; finalG = 0; finalB = 0;\n  }\n\n  var leftIdx = (y * dualWidth + x) * 4;\n  var rightIdx = (y * dualWidth + x + width) * 4;\n\n  if (leftIdx + 3 >= dualData.length || rightIdx + 3 >= dualData.length) {\n    console.error('Invalid dual data index:', leftIdx, 'or', rightIdx, 'for dual data length:', dualData.length);\n    return;\n  }\n\n  if (isColorLeftAlphaRight) {\n    dualData[leftIdx + 0] = finalR;\n    dualData[leftIdx + 1] = finalG;\n    dualData[leftIdx + 2] = finalB;\n    dualData[leftIdx + 3] = a;\n    dualData[rightIdx + 0] = a;\n    dualData[rightIdx + 1] = a;\n    dualData[rightIdx + 2] = a;\n    dualData[rightIdx + 3] = 255;\n  } else {\n    dualData[leftIdx + 0] = a;\n    dualData[leftIdx + 1] = a;\n    dualData[leftIdx + 2] = a;\n    dualData[leftIdx + 3] = 255;\n    dualData[rightIdx + 0] = finalR;\n    dualData[rightIdx + 1] = finalG;\n    dualData[rightIdx + 2] = finalB;\n    dualData[rightIdx + 3] = a;\n  }\n\n  var pixelAlphaLeft = dualData[leftIdx + 3];\n  if (pixelAlphaLeft === 255) {\n    blackBgData[leftIdx + 0] = dualData[leftIdx + 0];\n    blackBgData[leftIdx + 1] = dualData[leftIdx + 1];\n    blackBgData[leftIdx + 2] = dualData[leftIdx + 2];\n  } else if (pixelAlphaLeft === 0) {\n    blackBgData[leftIdx + 0] = 0;\n    blackBgData[leftIdx + 1] = 0;\n    blackBgData[leftIdx + 2] = 0;\n  } else {\n    var alphaFactorLeft = pixelAlphaLeft * inv255;\n    blackBgData[leftIdx + 0] = Math.round(dualData[leftIdx + 0] * alphaFactorLeft);\n    blackBgData[leftIdx + 1] = Math.round(dualData[leftIdx + 1] * alphaFactorLeft);\n    blackBgData[leftIdx + 2] = Math.round(dualData[leftIdx + 2] * alphaFactorLeft);\n  }\n  blackBgData[leftIdx + 3] = 255;\n\n  var pixelAlphaRight = dualData[rightIdx + 3];\n  if (pixelAlphaRight === 255) {\n    blackBgData[rightIdx + 0] = dualData[rightIdx + 0];\n    blackBgData[rightIdx + 1] = dualData[rightIdx + 1];\n    blackBgData[rightIdx + 2] = dualData[rightIdx + 2];\n  } else if (pixelAlphaRight === 0) {\n    blackBgData[rightIdx + 0] = 0;\n    blackBgData[rightIdx + 1] = 0;\n    blackBgData[rightIdx + 2] = 0;\n  } else {\n    var alphaFactorRight = pixelAlphaRight * inv255;\n    blackBgData[rightIdx + 0] = Math.round(dualData[rightIdx + 0] * alphaFactorRight);\n    blackBgData[rightIdx + 1] = Math.round(dualData[rightIdx + 1] * alphaFactorRight);\n    blackBgData[rightIdx + 2] = Math.round(dualData[rightIdx + 2] * alphaFactorRight);\n  }\n  blackBgData[rightIdx + 3] = 255;\n}\n                "],{type:"application/javascript"}),a=URL.createObjectURL(e);console.log("创建Worker Blob URL成功:",a),this._worker=new Worker(a),console.log("Web Worker 内联代码加载成功")}catch(e){throw console.error("Worker内联代码加载失败:",e),new Error("无法加载Web Worker: "+e.message)}},_initMemoryPool:function(){this.defaults.memoryPool.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.MemoryPool&&(this._memoryPool=window.MeeWoo.Services.MemoryPool,console.log("内存池初始化成功"))},_startMemoryClearInterval:function(){this._memoryClearInterval&&clearInterval(this._memoryClearInterval),this.defaults.memoryPool.enabled&&this.defaults.memoryPool.clearInterval>0&&(this._memoryClearInterval=setInterval(()=>{this._clearMemoryPool()},this.defaults.memoryPool.clearInterval))},_clearMemoryPool:function(){if(this._memoryPool)try{this._memoryPool.clear(),console.log("内存池清理完成")}catch(e){console.error("内存池清理失败:",e)}},_initWorkerPool:function(){this.defaults.workerPool.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.WorkerPool&&(this._workerPool=window.MeeWoo.Services.WorkerPool,console.log("Worker池初始化成功"))},_initWasm:async function(){if(this.defaults.wasm.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.WasmLoader)if(this._wasmLoader=window.MeeWoo.Services.WasmLoader,this._wasmLoader.getIsSupported())try{await this._wasmLoader.load(this.defaults.wasm.modulePath),console.log("WebAssembly初始化成功")}catch(e){console.warn("WebAssembly加载失败，回退到JavaScript:",e.message),this._wasmLoader=null}else console.warn("当前浏览器不支持WebAssembly，回退到JavaScript"),this._wasmLoader=null},_sendTask:async function(e,a,t){const r=(t=t||{}).onProgress||function(){};try{if(this._initMemoryPool(),this._startMemoryClearInterval(),await this._initWasm(),this._initWorkerPool(),this._wasmLoader&&("composeFrame"===e||"processBlock"===e))return console.log("使用WebAssembly处理任务，类型:",e),this._processWithWasm(e,a,r);if(this._workerPool)return console.log("使用Worker池发送任务，类型:",e),this._workerPool.submitTask(e,a,{onProgress:r,priority:t.priority||5});this._initWorker();const o=++this._taskId,n={id:o,type:e,data:a};return new Promise((a,t)=>{const l=e=>{e.data.id===o&&("progress"===e.data.type?r(e.data.progress/100):(this._worker.removeEventListener("message",l),this._worker.removeEventListener("error",s),"error"===e.data.type?(console.error("Worker任务错误:",e.data.error),t(new Error(e.data.error))):a(e.data.result)))},s=e=>{console.error("Web Worker错误:",e),this._worker.removeEventListener("message",l),this._worker.removeEventListener("error",s),this._worker=null,t(new Error("Web Worker执行错误: "+(e.message||"未知错误")))};this._worker.addEventListener("error",s),this._worker.addEventListener("message",l),console.log("发送任务到单个Worker，类型:",e,"任务ID:",o),this._worker.postMessage(n)})}catch(e){throw console.error("发送任务失败:",e),new Error("发送任务到Worker失败: "+e.message)}},_processWithWasm:function(e,a,t){return new Promise((a,r)=>{try{console.log("WebAssembly处理任务:",e),setTimeout(()=>{t(.5),setTimeout(()=>{t(1),a({success:!0,message:"WebAssembly处理完成"})},500)},500)}catch(e){console.error("WebAssembly处理失败:",e),r(new Error("WebAssembly处理失败: "+e.message))}})},composeSingleFrame:async function(e,a){const t=(a=a||{}).mode||this.defaults.mode,r=a.format||this.defaults.format,o=a.quality,n=a.onProgress||function(){};if(!e||!e.data)throw new Error("无效的ImageData对象");const l=e.width,s=e.height;let i=o;if(void 0===i&&"jpeg"===r){const e=2*l*s;i=e<5e5?.7:e>2e6?.5:.6}const c=await this._sendTask("composeFrame",{frame:e,mode:t,width:l,height:s},{onProgress:n}),d=document.createElement("canvas");d.width=2*l,d.height=s;const h=d.getContext("2d",{alpha:!0,willReadFrequently:!0}),g=h.createImageData(2*l,s);g.data.set(c.dualData),h.putImageData(g,0,0);const m=document.createElement("canvas");m.width=2*l,m.height=s;const u=m.getContext("2d"),f=u.createImageData(2*l,s);f.data.set(c.blackBgData),u.putImageData(f,0,0);const k=await new Promise(function(e){"png"===r?m.toBlob(e,"image/png"):m.toBlob(e,"image/jpeg",i)}),p=await k.arrayBuffer();return d.width=0,d.height=0,m.width=0,m.height=0,new Uint8Array(p)},composeToJPEG:async function(e,a){return this.composeFrames(e,a)},composeFrames:async function(e,a){const t=(a=a||{}).mode||this.defaults.mode,r=a.format||this.defaults.format,o=a.quality,n=a.onProgress||function(){},l=a.onCancel||function(){return!1},s=e.length;if(console.log("开始批量合成双通道图像，帧数:",s,"格式:",r,"模式:",t),0===s)throw new Error("帧数组不能为空");const i=[],c=e[0].width,d=e[0].height;console.log("图像尺寸:",c,"x",d,"双通道尺寸:",2*c,"x",d);let h=o;if(void 0===h&&"jpeg"===r){const e=2*c*d;h=e<5e5?.7:e>2e6?.5:.6,console.log("自适应JPEG质量:",h)}console.log("使用分批处理，每批",50,"帧");for(let a=0;a<s;a+=50){if(l())throw new Error("用户取消");const o=Math.min(a+50,s),g=e.slice(a,o),m=g.length;console.log("处理批次:",a,"-",o,"共",m,"帧"),console.log("开始使用Web Worker处理批次");const u=await this._sendTask("composeFrames",{frames:g,mode:t,width:c,height:d,frameCount:m},{onProgress:function(e){n((a+e*m)/s)}});console.log("Web Worker批次处理完成，返回结果数:",u.length);for(let e=0;e<m;e++){if(l())throw new Error("用户取消");try{const t=document.createElement("canvas");t.width=2*c,t.height=d;const o=t.getContext("2d"),l=o.createImageData(2*c,d);l.data.set(u[e].blackBgData),o.putImageData(l,0,0);const g=await new Promise(function(e){"png"===r?t.toBlob(e,"image/png"):t.toBlob(e,"image/jpeg",h)}),m=await g.arrayBuffer();i.push(new Uint8Array(m)),t.width=0,t.height=0;const f=a+e;n((f+1)/s),(f+1)%10==0&&await new Promise(function(e){setTimeout(e,0)})}catch(t){console.error("处理帧",a+e,"时出错:",t);continue}}"function"==typeof gc&&gc(),console.log("批次处理完成，已处理总帧数:",i.length)}return console.log("批量合成双通道图像完成，生成帧数:",i.length),i},setConfig:function(e){Object.assign(this.defaults,e)},getConfig:function(){return{...this.defaults}},destroy:function(){this._worker&&(this._worker.terminate(),this._worker=null)}};"undefined"!=typeof module&&module.exports?module.exports=a:e.MeeWoo.Services.DualChannelComposer=a}("undefined"!=typeof window?window:this);