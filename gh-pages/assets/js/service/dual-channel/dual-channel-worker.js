class MemoryPool{constructor(){this.pools=new Map,this.maxPoolSize=50,this.minBufferSize=1024,this.maxBufferSize=52428800}getBuffer(e){if(e<=0||e>this.maxBufferSize)return new Uint8ClampedArray(e);const o=this._roundUpToPowerOfTwo(e),r=`Uint8ClampedArray_${o}`;if(this.pools.has(r)&&this.pools.get(r).length>0){return this.pools.get(r).pop()}return new Uint8ClampedArray(o)}recycleBuffer(e){if(!e||!e.buffer)return;const o=e.length;if(o<=0||o>this.maxBufferSize)return;const r=`Uint8ClampedArray_${this._roundUpToPowerOfTwo(o)}`;this.pools.has(r)||this.pools.set(r,[]);const t=this.pools.get(r);t.length<this.maxPoolSize&&(e.fill(0),t.push(e))}clear(){this.pools.forEach(e=>{e.length=0}),this.pools.clear()}_roundUpToPowerOfTwo(e){return e<=this.minBufferSize?this.minBufferSize:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e)}}const memoryPool=new MemoryPool,BLOCK_SIZE=128,hasSIMD=!1;async function handleComposeFrame(e){console.log("Starting handleComposeFrame, frame data length:",e.frame.data.length,"width:",e.width,"height:",e.height);var o=e.frame.data,r=e.width,t=e.height,a="color-left-alpha-right"===e.mode,s=2*r,l=t,n=s*l*4;console.log("Dual channel image size:",s,"x",l,"data size:",n);var i=memoryPool.getBuffer(n),c=memoryPool.getBuffer(n);console.log("Memory allocated successfully");var h=[];console.log("Generating blocks...");for(var f=0;f<t;f+=128)for(var g=0;g<r;g+=128)h.push({x:g,y:f,width:Math.min(128,r-g),height:Math.min(128,t-f)});console.log("Generated",h.length,"blocks"),console.log("Starting parallel processing of blocks...");try{var m=0,d=h.length;await Promise.all(h.map(async l=>{await processBlock(l,o,r,t,s,i,c,a),m++;var n=Math.round(m/d*100);n%5==0&&self.postMessage({id:e.id,type:"progress",progress:n})})),console.log("Block processing completed")}catch(e){throw console.error("Error during block processing:",e),e}console.log("Posting result back to main thread"),self.postMessage({id:e.id,type:"result",result:{blackBgData:c,dualData:i,width:s,height:l}},[c.buffer,i.buffer]),console.log("Result posted successfully")}async function handleComposeFrames(e){console.log("Starting handleComposeFrames, frame count:",e.data.frames.length);var o=e.data,r=o.frames,t=o.mode,a=r.length;if(0===a)throw new Error("帧数组不能为空");console.log("First frame size:",r[0].width,"x",r[0].height);var s=[],l=r[0].width,n=r[0].height,i="color-left-alpha-right"===t,c=2*l,h=c*n*4;console.log("Dual channel image size per frame:",c,"x",n,"data size:",h);console.log("Worker使用分批处理，每批",20,"帧");for(let o=0;o<a;o+=20){const t=Math.min(o+20,a),m=r.slice(o,t),d=m.length;console.log("Worker处理批次:",o,"-",t,"共",d,"帧");var f=m.map(async function(e,r){const t=o+r;console.log("Processing frame",t+1,"of",a);var s=memoryPool.getBuffer(h),f=memoryPool.getBuffer(h);console.log("Memory allocated for frame",t);for(var g=[],m=0;m<n;m+=128)for(var d=0;d<l;d+=128)g.push({x:d,y:m,width:Math.min(128,l-d),height:Math.min(128,n-m)});console.log("Generated",g.length,"blocks for frame",t);try{await Promise.all(g.map(o=>processBlock(o,e.data,l,n,c,s,f,i))),console.log("Frame",t,"processing completed")}catch(e){return console.error("Error processing frame",t,":",e),null}return{blackBgData:f,width:c,height:n}});console.log("Waiting for batch frames to complete...");try{const o=(await Promise.all(f)).filter(e=>null!==e);s.push(...o),console.log("Batch processed successfully, valid results:",o.length);const r=Math.min(t,a);var g=Math.round(r/totalFrames*100);g%5==0&&self.postMessage({id:e.id,type:"progress",progress:g}),"function"==typeof gc&&gc(),console.log("Batch completed, total results so far:",s.length)}catch(e){console.error("Error in batch processing:",e);continue}}var m=[];s.forEach(e=>{m.push(e.blackBgData.buffer)}),console.log("Extracted transferable objects, count:",m.length),console.log("Posting results back to main thread"),self.postMessage({id:e.id,type:"result",result:s},m),console.log("Results posted successfully, total frames processed:",s.length)}function processBlock(e,o,r,t,a,s,l,n){return new Promise(function(i){var c=e.x,h=e.y,f=(e.width,e.height,1/255);try{processBlockWithoutSIMD(e,o,r,t,a,s,l,n,f),i()}catch(e){console.error("Error processing block:",e,"at position:",c,",",h),i()}})}function processBlockWithSIMD(e,o,r,t,a,s,l,n,i){}function process4PixelsWithSIMD(e,o,r,t,a,s,l,n,i,c,h,f){for(var g=[o*t+e,o*t+e+1,o*t+e+2,o*t+e+3].map(e=>4*e),m=SIMD.int32x4(r[g[0]],r[g[1]],r[g[2]],r[g[3]]),d=SIMD.int32x4(r[g[0]+1],r[g[1]+1],r[g[2]+1],r[g[3]+1]),p=SIMD.int32x4(r[g[0]+2],r[g[1]+2],r[g[2]+2],r[g[3]+2]),u=(SIMD.int32x4(r[g[0]+3],r[g[1]+3],r[g[2]+3],r[g[3]+3]),m),M=d,y=p,v=0;v<4;v++){var x=r[g[v]+3];if(x>0&&x<255){var w=255*i;u=SIMD.int32x4.replaceLane(u,v,Math.min(255,Math.round(r[g[v]]*w))),M=SIMD.int32x4.replaceLane(M,v,Math.min(255,Math.round(r[g[v]+1]*w))),y=SIMD.int32x4.replaceLane(y,v,Math.min(255,Math.round(r[g[v]+2]*w)))}else 0===x&&(u=SIMD.int32x4.replaceLane(u,v,0),M=SIMD.int32x4.replaceLane(M,v,0),y=SIMD.int32x4.replaceLane(y,v,0))}for(v=0;v<4;v++){var S=e+v,k=4*(o*t+S),B=SIMD.int32x4.extractLane(u,v),D=SIMD.int32x4.extractLane(M,v),P=SIMD.int32x4.extractLane(y,v),b=r[k+3],I=4*(o*a+S),F=4*(o*a+S+t);n?(s[I+0]=B,s[I+1]=D,s[I+2]=P,s[I+3]=b,s[F+0]=b,s[F+1]=b,s[F+2]=b,s[F+3]=255):(s[I+0]=b,s[I+1]=b,s[I+2]=b,s[I+3]=255,s[F+0]=B,s[F+1]=D,s[F+2]=P,s[F+3]=b);var C=s[I+3];if(255===C)l[I+0]=s[I+0],l[I+1]=s[I+1],l[I+2]=s[I+2];else if(0===C)l[I+0]=0,l[I+1]=0,l[I+2]=0;else{var E=C*i;l[I+0]=Math.round(s[I+0]*E),l[I+1]=Math.round(s[I+1]*E),l[I+2]=Math.round(s[I+2]*E)}l[I+3]=255;var z=s[F+3];if(255===z)l[F+0]=s[F+0],l[F+1]=s[F+1],l[F+2]=s[F+2];else if(0===z)l[F+0]=0,l[F+1]=0,l[F+2]=0;else{var L=z*i;l[F+0]=Math.round(s[F+0]*L),l[F+1]=Math.round(s[F+1]*L),l[F+2]=Math.round(s[F+2]*L)}l[F+3]=255}}function processBlockWithoutSIMD(e,o,r,t,a,s,l,n,i){for(var c=e.x,h=e.y,f=e.width,g=e.height,m=h;m<h+g;m++)for(var d=c;d<c+f;d++)try{processSinglePixel(d,m,o,r,a,s,l,n,i)}catch(e){console.error("Error processing pixel at",d,",",m,":",e)}}function processSinglePixel(e,o,r,t,a,s,l,n,i){var c=4*(o*t+e);if(c+3>=r.length)console.error("Invalid frame index:",c,"for frame data length:",r.length);else{var h=r[c+0],f=r[c+1],g=r[c+2],m=r[c+3],d=h,p=f,u=g;if(m>0){if(m<255){var M=255*i;d=Math.min(255,Math.round(h*M)),p=Math.min(255,Math.round(f*M)),u=Math.min(255,Math.round(g*M))}}else d=0,p=0,u=0;var y=4*(o*a+e),v=4*(o*a+e+t);if(y+3>=s.length||v+3>=s.length)console.error("Invalid dual data index:",y,"or",v,"for dual data length:",s.length);else{n?(s[y+0]=d,s[y+1]=p,s[y+2]=u,s[y+3]=m,s[v+0]=m,s[v+1]=m,s[v+2]=m,s[v+3]=255):(s[y+0]=m,s[y+1]=m,s[y+2]=m,s[y+3]=255,s[v+0]=d,s[v+1]=p,s[v+2]=u,s[v+3]=m);var x=s[y+3];if(255===x)l[y+0]=s[y+0],l[y+1]=s[y+1],l[y+2]=s[y+2];else if(0===x)l[y+0]=0,l[y+1]=0,l[y+2]=0;else{var w=x*i;l[y+0]=Math.round(s[y+0]*w),l[y+1]=Math.round(s[y+1]*w),l[y+2]=Math.round(s[y+2]*w)}l[y+3]=255;var S=s[v+3];if(255===S)l[v+0]=s[v+0],l[v+1]=s[v+1],l[v+2]=s[v+2];else if(0===S)l[v+0]=0,l[v+1]=0,l[v+2]=0;else{var k=S*i;l[v+0]=Math.round(s[v+0]*k),l[v+1]=Math.round(s[v+1]*k),l[v+2]=Math.round(s[v+2]*k)}l[v+3]=255}}}self.onmessage=function(e){var o=e.data;console.log("Worker received task:",o.type,"Task ID:",o.id);try{switch(o.type){case"composeFrame":console.log("Processing composeFrame task"),handleComposeFrame(o).catch(function(e){console.error("Error in handleComposeFrame:",e),self.postMessage({id:o.id,type:"error",error:e.message})});break;case"composeFrames":console.log("Processing composeFrames task, frame count:",o.data.frames.length),handleComposeFrames(o).catch(function(e){console.error("Error in handleComposeFrames:",e),self.postMessage({id:o.id,type:"error",error:e.message})});break;case"clearMemory":console.log("Clearing memory pool"),memoryPool.clear(),self.postMessage({id:o.id,type:"success"});break;default:throw new Error("Unknown task type: "+o.type)}}catch(e){console.error("Error in message handler:",e),self.postMessage({id:o.id,type:"error",error:e.message})}};