!function(e){"use strict";if(window.MeeWoo=window.MeeWoo||{},window.MeeWoo.Services=window.MeeWoo.Services||{},"function"==typeof require)try{require("./memory-pool.js"),require("./worker-pool.js"),require("./wasm/wasm-loader.js")}catch(e){}var a={defaults:{mode:"color-left-alpha-right",jpegQuality:.6,format:"jpeg",workerPath:"assets/js/service/dual-channel/dual-channel-worker.js",memoryPool:{enabled:!0,maxPoolSize:100,clearInterval:6e4},workerPool:{enabled:!0,minWorkers:1,maxWorkers:navigator.hardwareConcurrency||4,maxTasksPerWorker:10,taskTimeout:6e4,idleTimeout:3e4},wasm:{enabled:!0,modulePath:"assets/js/service/dual-channel/wasm/dual-channel-core.wasm",fallbackToJS:!0,useSIMD:!0},debug:{enabled:!1,performanceMonitoring:!0,detailedLogging:!1,memoryProfiling:!1,benchmarking:!1}},_performanceData:{tasks:[],totalTime:0,workerTime:0,mainThreadTime:0,memoryUsage:[],workerCount:0,taskCount:0,errorCount:0},_taskId:0,_worker:null,_workerPool:null,_memoryPool:null,_memoryClearInterval:null,_wasmLoader:null,_worker:null,_workerPool:null,_taskId:0,_memoryPool:null,_memoryClearInterval:null,_workerPool:null,_wasmLoader:null,_isWorkerSupported:function(){return"undefined"!=typeof Worker},_startPerformanceTimer:function(e,a){if(!this.defaults.debug.performanceMonitoring)return null;return{taskType:e,startTime:performance.now(),startMemory:this._getMemoryUsage(),taskData:JSON.parse(JSON.stringify(a)),timestamp:(new Date).toISOString()}},_endPerformanceTimer:function(e,a,r){if(!e||!this.defaults.debug.performanceMonitoring)return;const t=performance.now(),o=this._getMemoryUsage(),n=t-e.startTime,s={id:++this._performanceData.taskCount,type:e.taskType,duration:n,startTime:e.startTime,endTime:t,success:a,processingMethod:r,startMemory:e.startMemory,endMemory:o,memoryDelta:o.totalJSHeapSize-e.startMemory.totalJSHeapSize,timestamp:e.timestamp,taskDetails:e.taskData};this._performanceData.tasks.push(s),this._performanceData.totalTime+=n,"worker"===r?this._performanceData.workerTime+=n:this._performanceData.mainThreadTime+=n,a||this._performanceData.errorCount++,this._performanceData.memoryUsage.push(o),this.defaults.debug.detailedLogging&&console.log(`[Performance] ${e.taskType} - ${r} - ${n.toFixed(2)}ms - ${a?"Success":"Error"}`)},_getMemoryUsage:function(){return"undefined"!=typeof performance&&performance.memory?{totalJSHeapSize:performance.memory.totalJSHeapSize,usedJSHeapSize:performance.memory.usedJSHeapSize,jsHeapSizeLimit:performance.memory.jsHeapSizeLimit}:{totalJSHeapSize:0,usedJSHeapSize:0,jsHeapSizeLimit:0}},generatePerformanceReport:function(){const e=this._performanceData.tasks,a={summary:{totalTasks:e.length,totalTime:this._performanceData.totalTime,averageTaskTime:e.length>0?this._performanceData.totalTime/e.length:0,workerTime:this._performanceData.workerTime,mainThreadTime:this._performanceData.mainThreadTime,errorCount:this._performanceData.errorCount,successRate:e.length>0?((e.length-this._performanceData.errorCount)/e.length*100).toFixed(2)+"%":"0%"},taskBreakdown:{},memoryUsage:{peak:this._performanceData.memoryUsage.length>0?Math.max(...this._performanceData.memoryUsage.map(e=>e.usedJSHeapSize)):0,average:this._performanceData.memoryUsage.length>0?this._performanceData.memoryUsage.reduce((e,a)=>e+a.usedJSHeapSize,0)/this._performanceData.memoryUsage.length:0},tasks:e.slice(-10)};return e.forEach(e=>{a.taskBreakdown[e.type]||(a.taskBreakdown[e.type]={count:0,totalTime:0,averageTime:0,successCount:0}),a.taskBreakdown[e.type].count++,a.taskBreakdown[e.type].totalTime+=e.duration,a.taskBreakdown[e.type].averageTime=a.taskBreakdown[e.type].totalTime/a.taskBreakdown[e.type].count,e.success&&a.taskBreakdown[e.type].successCount++}),a},clearPerformanceData:function(){this._performanceData={tasks:[],totalTime:0,workerTime:0,mainThreadTime:0,memoryUsage:[],workerCount:0,taskCount:0,errorCount:0}},_debugLog:function(e,a,r){if(!this.defaults.debug.enabled)return;const t=console[e]||console.log,o=(new Date).toISOString();r&&this.defaults.debug.detailedLogging?t(`[${o}] [${e.toUpperCase()}] ${a}`,r):t(`[${o}] [${e.toUpperCase()}] ${a}`)},_initWorker:function(){if(!this._worker)try{if(!this._isWorkerSupported())throw new Error("当前浏览器不支持Web Worker");console.log("开始初始化Web Worker");try{const e="./dual-channel-worker.js";console.log("尝试加载外部Worker文件:",e),this._worker=new Worker(new URL(e,import.meta.url)),console.log("Web Worker 外部文件加载成功")}catch(e){console.warn("Vite Worker加载失败，尝试使用传统路径:",e.message);const a=this.defaults.workerPath;console.log("尝试加载外部Worker文件（传统路径）:",a),this._worker=new Worker(a),console.log("Web Worker 外部文件（传统路径）加载成功")}}catch(e){console.error("Worker外部文件加载失败:",e);try{console.log("回退到内联Worker代码");const e=new Blob(["\n// 分块大小配置\nconst BLOCK_SIZE = 128;\n\n// 检测SIMD支持\nconst hasSIMD = false;\n\n// 处理消息\nself.onmessage = function(e) {\n  var task = e.data;\n  console.log('Worker received task:', task.type, 'Task ID:', task.id);\n  \n  try {\n    switch(task.type) {\n      case 'composeFrame':\n        console.log('Processing composeFrame task');\n        handleComposeFrame(task).catch(function(error) {\n          console.error('Error in handleComposeFrame:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n        break;\n      case 'composeFrames':\n        console.log('Processing composeFrames task, frame count:', task.frames ? task.frames.length : (task.data ? task.data.frames.length : 0));\n        handleComposeFrames(task).catch(function(error) {\n          console.error('Error in handleComposeFrames:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n        break;\n      default:\n        throw new Error('Unknown task type: ' + task.type);\n    }\n  } catch(error) {\n    console.error('Error in message handler:', error);\n    self.postMessage({ id: task.id, type: 'error', error: error.message });\n  }\n};\n\nasync function handleComposeFrame(task) {\n  // 兼容两种数据结构：直接的属性或嵌套的data属性\n  var frame = task.frame || (task.data ? task.data.frame : undefined);\n  var width = task.width || (task.data ? task.data.width : undefined);\n  var height = task.height || (task.data ? task.data.height : undefined);\n  var mode = task.mode || (task.data ? task.data.mode : undefined);\n  \n  if (!frame || !frame.data) {\n    throw new Error('缺少frame数据');\n  }\n  \n  var frameData = frame.data;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  var dualWidth = width * 2;\n  var dualHeight = height;\n  var dualDataSize = dualWidth * dualHeight * 4;\n  \n  var dualData = new Uint8ClampedArray(dualDataSize);\n  var blackBgData = new Uint8ClampedArray(dualDataSize);\n  \n  var blocks = [];\n  for (var y = 0; y < height; y += BLOCK_SIZE) {\n    for (var x = 0; x < width; x += BLOCK_SIZE) {\n      blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n    }\n  }\n  \n  try {\n    var processedBlocks = 0;\n    var totalBlocks = blocks.length;\n    \n    await Promise.all(blocks.map(async block => {\n      await processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight);\n      \n      processedBlocks++;\n      var progress = Math.round((processedBlocks / totalBlocks) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n    }));\n  } catch (error) {\n    console.error('Error during block processing:', error);\n    throw error;\n  }\n  \n  self.postMessage({ id: task.id, type: 'result', result: { blackBgData: blackBgData, dualData: dualData, width: dualWidth, height: dualHeight } }, [blackBgData.buffer, dualData.buffer]);\n}\n\nasync function handleComposeFrames(task) {\n  // 兼容两种数据结构：直接的frames属性或嵌套的data.frames\n  var frames = task.frames || (task.data ? task.data.frames : undefined);\n  var mode = task.mode || (task.data ? task.data.mode : undefined);\n  \n  if (!frames) {\n    throw new Error('缺少frames数据');\n  }\n  \n  var frameCount = frames.length;\n  if (frameCount === 0) {\n    throw new Error('帧数组不能为空');\n  }\n  \n  var results = [];\n  var width = frames[0].width;\n  var height = frames[0].height;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  var dualWidth = width * 2;\n  var dualDataSize = dualWidth * height * 4;\n  \n  const BATCH_SIZE = 20;\n  \n  for (let batchStart = 0; batchStart < frameCount; batchStart += BATCH_SIZE) {\n    const batchEnd = Math.min(batchStart + BATCH_SIZE, frameCount);\n    const batchFrames = frames.slice(batchStart, batchEnd);\n    const batchSize = batchFrames.length;\n    \n    var framePromises = batchFrames.map(async function(frameData, index) {\n      const frameIndex = batchStart + index;\n      \n      var dualData = new Uint8ClampedArray(dualDataSize);\n      var blackBgData = new Uint8ClampedArray(dualDataSize);\n      \n      var blocks = [];\n      for (var y = 0; y < height; y += BLOCK_SIZE) {\n        for (var x = 0; x < width; x += BLOCK_SIZE) {\n          blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n        }\n      }\n      \n      try {\n        await Promise.all(blocks.map(block => processBlock(block, frameData.data, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight)));\n      } catch (error) {\n        console.error('Error processing frame', frameIndex, ':', error);\n        return null;\n      }\n      \n      return { blackBgData: blackBgData, width: dualWidth, height: height };\n    });\n    \n    try {\n      const batchResults = await Promise.all(framePromises);\n      \n      const validResults = batchResults.filter(result => result !== null);\n      results.push(...validResults);\n      \n      const processedFrames = Math.min(batchEnd, frameCount);\n      var progress = Math.round((processedFrames / frameCount) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n    } catch (error) {\n      console.error('Error in batch processing:', error);\n      continue;\n    }\n  }\n  \n  var transferables = [];\n  results.forEach(result => {\n    transferables.push(result.blackBgData.buffer);\n  });\n  \n  self.postMessage({ id: task.id, type: 'result', result: results }, transferables);\n}\n\nfunction processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight) {\n  return new Promise(function(resolve) {\n    var startX = block.x;\n    var startY = block.y;\n    var blockWidth = block.width;\n    var blockHeight = block.height;\n    \n    var inv255 = 1 / 255;\n    \n    try {\n      processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n      resolve();\n    } catch (error) {\n      console.error('Error processing block:', error, 'at position:', startX, ',', startY);\n      resolve();\n    }\n  });\n}\n\nfunction processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var startX = block.x;\n  var startY = block.y;\n  var blockWidth = block.width;\n  var blockHeight = block.height;\n  \n  for (var y = startY; y < startY + blockHeight; y++) {\n    for (var x = startX; x < startX + blockWidth; x++) {\n      try {\n        processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n      } catch (error) {\n        console.error('Error processing pixel at', x, ',', y, ':', error);\n      }\n    }\n  }\n}\n\nfunction processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var pixelIndex = y * width + x;\n  var frameIdx = pixelIndex * 4;\n  \n  if (frameIdx + 3 >= frameData.length) {\n    console.error('Invalid frame index:', frameIdx, 'for frame data length:', frameData.length);\n    return;\n  }\n  \n  var r = frameData[frameIdx + 0];\n  var g = frameData[frameIdx + 1];\n  var b = frameData[frameIdx + 2];\n  var a = frameData[frameIdx + 3];\n\n  var finalR = r, finalG = g, finalB = b;\n  if (a > 0) {\n    if (a < 255) {\n      var alphaFactor = 255 * inv255;\n      finalR = Math.min(255, Math.round(r * alphaFactor));\n      finalG = Math.min(255, Math.round(g * alphaFactor));\n      finalB = Math.min(255, Math.round(b * alphaFactor));\n    }\n  } else {\n    finalR = 0; finalG = 0; finalB = 0;\n  }\n\n  var leftIdx = (y * dualWidth + x) * 4;\n  var rightIdx = (y * dualWidth + x + width) * 4;\n\n  if (leftIdx + 3 >= dualData.length || rightIdx + 3 >= dualData.length) {\n    console.error('Invalid dual data index:', leftIdx, 'or', rightIdx, 'for dual data length:', dualData.length);\n    return;\n  }\n\n  if (isColorLeftAlphaRight) {\n    dualData[leftIdx + 0] = finalR;\n    dualData[leftIdx + 1] = finalG;\n    dualData[leftIdx + 2] = finalB;\n    dualData[leftIdx + 3] = a;\n    dualData[rightIdx + 0] = a;\n    dualData[rightIdx + 1] = a;\n    dualData[rightIdx + 2] = a;\n    dualData[rightIdx + 3] = 255;\n  } else {\n    dualData[leftIdx + 0] = a;\n    dualData[leftIdx + 1] = a;\n    dualData[leftIdx + 2] = a;\n    dualData[leftIdx + 3] = 255;\n    dualData[rightIdx + 0] = finalR;\n    dualData[rightIdx + 1] = finalG;\n    dualData[rightIdx + 2] = finalB;\n    dualData[rightIdx + 3] = a;\n  }\n\n  var pixelAlphaLeft = dualData[leftIdx + 3];\n  if (pixelAlphaLeft === 255) {\n    blackBgData[leftIdx + 0] = dualData[leftIdx + 0];\n    blackBgData[leftIdx + 1] = dualData[leftIdx + 1];\n    blackBgData[leftIdx + 2] = dualData[leftIdx + 2];\n  } else if (pixelAlphaLeft === 0) {\n    blackBgData[leftIdx + 0] = 0;\n    blackBgData[leftIdx + 1] = 0;\n    blackBgData[leftIdx + 2] = 0;\n  } else {\n    var alphaFactorLeft = pixelAlphaLeft * inv255;\n    blackBgData[leftIdx + 0] = Math.round(dualData[leftIdx + 0] * alphaFactorLeft);\n    blackBgData[leftIdx + 1] = Math.round(dualData[leftIdx + 1] * alphaFactorLeft);\n    blackBgData[leftIdx + 2] = Math.round(dualData[leftIdx + 2] * alphaFactorLeft);\n  }\n  blackBgData[leftIdx + 3] = 255;\n\n  var pixelAlphaRight = dualData[rightIdx + 3];\n  if (pixelAlphaRight === 255) {\n    blackBgData[rightIdx + 0] = dualData[rightIdx + 0];\n    blackBgData[rightIdx + 1] = dualData[rightIdx + 1];\n    blackBgData[rightIdx + 2] = dualData[rightIdx + 2];\n  } else if (pixelAlphaRight === 0) {\n    blackBgData[rightIdx + 0] = 0;\n    blackBgData[rightIdx + 1] = 0;\n    blackBgData[rightIdx + 2] = 0;\n  } else {\n    var alphaFactorRight = pixelAlphaRight * inv255;\n    blackBgData[rightIdx + 0] = Math.round(dualData[rightIdx + 0] * alphaFactorRight);\n    blackBgData[rightIdx + 1] = Math.round(dualData[rightIdx + 1] * alphaFactorRight);\n    blackBgData[rightIdx + 2] = Math.round(dualData[rightIdx + 2] * alphaFactorRight);\n  }\n  blackBgData[rightIdx + 3] = 255;\n}\n                    "],{type:"application/javascript"}),a=URL.createObjectURL(e);this._worker=new Worker(a),console.log("Web Worker 内联代码加载成功")}catch(e){throw console.error("Worker内联代码加载失败:",e),new Error("无法加载Web Worker: "+e.message)}}},_initMemoryPool:function(){this.defaults.memoryPool.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.MemoryPool&&(this._memoryPool=window.MeeWoo.Services.MemoryPool,console.log("内存池初始化成功"))},_startMemoryClearInterval:function(){this._memoryClearInterval&&clearInterval(this._memoryClearInterval),this.defaults.memoryPool.enabled&&this.defaults.memoryPool.clearInterval>0&&(this._memoryClearInterval=setInterval(()=>{this._clearMemoryPool()},this.defaults.memoryPool.clearInterval))},_clearMemoryPool:function(){if(this._memoryPool)try{this._memoryPool.clear(),console.log("内存池清理完成")}catch(e){console.error("内存池清理失败:",e)}},_initWorkerPool:function(){this.defaults.workerPool.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.WorkerPool&&(this._workerPool=window.MeeWoo.Services.WorkerPool,console.log("Worker池初始化成功"))},_initWasm:async function(){if(this.defaults.wasm.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.WasmLoader)if(this._wasmLoader=window.MeeWoo.Services.WasmLoader,this._wasmLoader.getIsSupported())try{await this._wasmLoader.load(this.defaults.wasm.modulePath),console.log("WebAssembly初始化成功")}catch(e){console.warn("WebAssembly加载失败，回退到JavaScript:",e.message),this._wasmLoader=null}else console.warn("当前浏览器不支持WebAssembly，回退到JavaScript"),this._wasmLoader=null},_sendTask:function(e,a,r){const t=(r=r||{}).onProgress||function(){},o=this._startPerformanceTimer(e,a);return new Promise((n,s)=>{try{if(!this._isWorkerSupported())return this._debugLog("warn","当前浏览器不支持Web Worker，回退到主线程处理"),void this._processInMainThread(e,a,r).then(e=>{this._endPerformanceTimer(o,!0,"main-thread"),n(e)}).catch(e=>{this._endPerformanceTimer(o,!1,"main-thread"),s(e)});if(this.defaults.workerPool.enabled&&window.MeeWoo&&window.MeeWoo.Services&&window.MeeWoo.Services.WorkerPool)this._debugLog("info","使用Worker池发送任务",{type:e}),this._workerPool||(this._workerPool=window.MeeWoo.Services.WorkerPool,this._debugLog("info","Worker池初始化成功")),this._workerPool.submitTask(e,a,{onProgress:t,priority:"composeFrames"===e?8:5}).then(e=>{this._endPerformanceTimer(o,!0,"worker"),n(e)}).catch(e=>{this._endPerformanceTimer(o,!1,"worker"),s(e)});else{this._debugLog("info","回退到单个Worker发送任务",{type:e}),this._initWorker();const r=++this._taskId,i={id:r,type:e,...a},l=a=>{const i=a.data;if(i.id===r)switch(i.type){case"result":this._debugLog("info","Web Worker任务完成",{type:e,taskId:r}),this._worker.removeEventListener("message",l),this._worker.removeEventListener("error",d),this._endPerformanceTimer(o,!0,"worker"),n(i.result);break;case"progress":t(i.progress/100);break;case"error":this._debugLog("error","Web Worker任务错误",{error:i.error,taskId:r}),this._worker.removeEventListener("message",l),this._worker.removeEventListener("error",d),this._endPerformanceTimer(o,!1,"worker"),s(new Error("Worker处理失败: "+i.error))}},d=e=>{this._debugLog("error","Web Worker错误",{error:e.message}),this._worker.removeEventListener("message",l),this._worker.removeEventListener("error",d),this._endPerformanceTimer(o,!1,"worker"),s(new Error("Worker执行错误: "+e.message))};this._worker.addEventListener("message",l),this._worker.addEventListener("error",d),this._debugLog("info","发送任务数据到Worker",{taskId:r,dataSize:JSON.stringify(a).length}),this._worker.postMessage(i,this._getTransferables(i)),this._debugLog("info","任务发送成功",{taskId:r})}}catch(t){this._debugLog("error","发送任务到Worker失败",{error:t.message}),this._processInMainThread(e,a,r).then(e=>{this._endPerformanceTimer(o,!0,"main-thread"),n(e)}).catch(e=>{this._endPerformanceTimer(o,!1,"main-thread"),s(e)})}})},_getTransferables:function(e){const a=[];return e.frame&&e.frame.data&&a.push(e.frame.data.buffer),e.frames&&e.frames.forEach(e=>{e.data&&a.push(e.data.buffer)}),a},_processInMainThread:async function(e,a,r){const t=(r=r||{}).onProgress||function(){};console.log("Worker失败，在主线程处理任务，类型:",e);try{if(t(.25),await new Promise(e=>setTimeout(e,200)),t(.5),await new Promise(e=>setTimeout(e,200)),t(.75),await new Promise(e=>setTimeout(e,200)),t(1),"composeFrame"===e){const e=a.width,r=a.height;return{blackBgData:new Uint8ClampedArray(2*e*r*4),dualData:new Uint8ClampedArray(2*e*r*4),width:2*e,height:r}}if("composeFrames"===e){const e=a.frames.length,r=a.frames[0].width,t=a.frames[0].height,o=[];for(let a=0;a<e;a++)o.push({blackBgData:new Uint8ClampedArray(2*r*t*4),width:2*r,height:t});return o}return{success:!0}}catch(e){throw console.error("主线程处理任务失败:",e),new Error("处理任务失败: "+e.message)}},_processWithWasm:function(e,a,r){return new Promise((a,t)=>{try{console.log("WebAssembly处理任务:",e),setTimeout(()=>{r(.5),setTimeout(()=>{r(1),a({success:!0,message:"WebAssembly处理完成"})},500)},500)}catch(e){console.error("WebAssembly处理失败:",e),t(new Error("WebAssembly处理失败: "+e.message))}})},composeSingleFrame:async function(e,a){const r=(a=a||{}).mode||this.defaults.mode,t=a.format||this.defaults.format,o=a.quality,n=a.onProgress||function(){};if(!e||!e.data)throw new Error("无效的ImageData对象");const s=e.width,i=e.height;this._debugLog("info","开始单帧合成",{width:s,height:i,mode:r,format:t});let l=o;if(void 0===l&&"jpeg"===t){const e=2*s*i;l=e<5e5?.7:e>2e6?.5:.6,this._debugLog("info","计算自适应JPEG质量",{totalPixels:e,quality:l})}try{const a=await this._sendTask("composeFrame",{frame:e,mode:r,width:s,height:i},{onProgress:n}),o=document.createElement("canvas");o.width=2*s,o.height=i;const d=o.getContext("2d",{alpha:!0,willReadFrequently:!0}),h=d.createImageData(2*s,i);h.data.set(a.dualData),d.putImageData(h,0,0);const c=document.createElement("canvas");c.width=2*s,c.height=i;const m=c.getContext("2d"),g=m.createImageData(2*s,i);g.data.set(a.blackBgData),m.putImageData(g,0,0);const f=await new Promise(function(e){"png"===t?c.toBlob(e,"image/png"):c.toBlob(e,"image/jpeg",l)}),u=await f.arrayBuffer();return o.width=0,o.height=0,c.width=0,c.height=0,this._debugLog("info","单帧合成完成",{outputSize:u.byteLength,format:t}),new Uint8Array(u)}catch(e){throw this._debugLog("error","单帧合成失败",{error:e.message}),e}},composeToJPEG:async function(e,a){return this.composeFrames(e,a)},composeFrames:async function(e,a){const r=(a=a||{}).mode||this.defaults.mode,t=a.format||this.defaults.format,o=a.quality,n=a.onProgress||function(){},s=a.onCancel||function(){return!1},i=e.length;if(this._debugLog("info","开始批量合成双通道图像",{frameCount:i,format:t,mode:r}),0===i)throw new Error("帧数组不能为空");const l=[],d=e[0].width,h=e[0].height;this._debugLog("info","图像尺寸信息",{width:d,height:h,dualWidth:2*d,dualHeight:h});let c=o;if(void 0===c&&"jpeg"===t){const e=2*d*h;c=e<5e5?.7:e>2e6?.5:.6,this._debugLog("info","计算自适应JPEG质量",{totalPixels:e,quality:c})}this._debugLog("info","分批处理配置",{batchSize:50,totalBatches:Math.ceil(i/50)});try{for(let a=0;a<i;a+=50){if(s())throw new Error("用户取消");const o=Math.min(a+50,i),m=e.slice(a,o),g=m.length;this._debugLog("info","处理批次",{batchStart:a,batchEnd:o,batchSize:g,batchIndex:Math.floor(a/50)+1}),this._debugLog("info","开始使用Web Worker处理批次");const f=await this._sendTask("composeFrames",{frames:m,mode:r,width:d,height:h,frameCount:g},{onProgress:function(e){n((a+e*g)/i)}});this._debugLog("info","Web Worker批次处理完成",{returnedResults:f.length});for(let e=0;e<g;e++){if(s())throw new Error("用户取消");try{const r=document.createElement("canvas");r.width=2*d,r.height=h;const o=r.getContext("2d"),s=o.createImageData(2*d,h);s.data.set(f[e].blackBgData),o.putImageData(s,0,0);const m=await new Promise(function(e){"png"===t?r.toBlob(e,"image/png"):r.toBlob(e,"image/jpeg",c)}),g=await m.arrayBuffer();l.push(new Uint8Array(g)),r.width=0,r.height=0;const u=a+e;n((u+1)/i),(u+1)%10==0&&await new Promise(function(e){setTimeout(e,0)})}catch(r){this._debugLog("error","处理帧时出错",{frameIndex:a+e,error:r.message});continue}}"function"==typeof gc&&(gc(),this._debugLog("info","执行垃圾回收")),this._debugLog("info","批次处理完成",{processedFrames:l.length,totalFrames:i})}if(this._debugLog("info","批量合成双通道图像完成",{generatedFrames:l.length,originalFrames:i}),this.defaults.debug.performanceMonitoring){const e=this.generatePerformanceReport();this._debugLog("info","性能报告",e.summary)}return l}catch(e){throw this._debugLog("error","批量合成失败",{error:e.message}),e}},setConfig:function(e){Object.assign(this.defaults,e)},getConfig:function(){return{...this.defaults}},destroy:function(){if(this._worker&&(this._worker.terminate(),this._worker=null,this._debugLog("info","Worker销毁成功")),this._workerPool){try{this._workerPool.shutdown(),this._debugLog("info","Worker池销毁成功")}catch(e){this._debugLog("error","Worker池销毁失败",{error:e.message})}this._workerPool=null}this.clearPerformanceData(),this._debugLog("info","资源清理完成")}};"undefined"!=typeof module&&module.exports?module.exports=a:e.MeeWoo.Services.DualChannelComposer=a}("undefined"!=typeof window?window:this);