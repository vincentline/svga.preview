# 侧边弹窗开发经验文档

## 1. 概述

本文档记录了 MeeWoo 项目中侧边弹窗的开发经验和最佳实践，旨在指导后续侧边弹窗的开发，避免重复犯同样的错误，提高开发效率和代码质量。

## 1.1 技术栈概览

| 类别 | 技术/依赖 | 版本 | 用途 |
|------|----------|------|------|
| 前端框架 | Vue | 2.7.15 | 组件化开发、响应式数据绑定 |
| 样式 | CSS3 | - | 过渡动画、Flexbox布局、暗黑模式支持 |
| 构建工具 | Vite | - | 开发服务器、代码构建 |
| 动画库 | SVGA Player | - | SVGA动画预览 |
| 媒体处理 | FFmpeg | - | MP4转换、视频处理 |
| 动画库 | Lottie | - | Lottie动画预览 |
| 音频库 | Howler | - | 音频处理 |

## 1.2 运行环境

- **浏览器**：Chrome（推荐）
- **操作系统**：Windows
- **开发服务器**：Vite
- **网络要求**：支持ES6+、Web Workers
- **硬件要求**：支持Canvas、WebGL渲染

## 2. 技术规范

### 2.1 面板结构

所有侧边弹窗应遵循以下基本结构：

```html
<div class="side-panel side-panel--right [特定面板类]" :class="{'show': visible}">
  <div class="side-panel-container">
    <!-- 标题区 -->
    <div class="side-panel-header">
      <h3 class="side-panel-title">面板标题</h3>
      <div class="side-panel-divider"></div>
    </div>

    <!-- 信息区 -->
    <div class="[类型]-info-section">
      <div class="[类型]-info-row">信息内容</div>
      <div class="[类型]-compress-hint">提示信息</div>
    </div>

    <!-- 配置区域 -->
    <div class="[类型]-config-section">
      <!-- 配置项 -->
    </div>

    <!-- 底部按钮 -->
    <div class="side-panel-footer">
      <!-- 按钮 -->
    </div>
  </div>
</div>
```

### 2.2 组件实现技术

#### 2.2.1 Vue组件注册

使用全局命名空间注册Vue组件，确保组件在Vue加载完成后注册：

```javascript
// 确保Vue加载完成后注册组件（适配Vue2）
function registerComponent() {
  if (window.Vue) {
    // 注册组件，让Vue识别<component-name>标签
    Vue.component('component-name', global.MeeWoo.Components.ComponentName);
  } else {
    // 如果Vue还没加载，延迟重试
    setTimeout(registerComponent, 600);
  }
}

// 执行注册
registerComponent();
```

#### 2.2.2 拖拽功能实现

使用原生JavaScript实现面板拖拽功能：

- **拖拽区域**：仅在标题区域显示move光标
- **拖拽状态**：拖拽过程中禁用过渡动画
- **位置记忆**：保持用户拖拽后的位置

#### 2.2.3 强制显示机制

为解决模板渲染延迟问题，实现强制显示机制：

```javascript
forceShowPanel: function (retryCount) {
  retryCount = retryCount || 0;
  // 增加重试次数，适配模板渲染延迟
  if (retryCount > 30) {
    return;
  }
  
  try {
    // 等Vue的nextTick（确保模板渲染）
    this.$nextTick(() => {
      try {
        // 查找面板元素
        var panelElement = null;
        
        // 方法1：使用组件的$el属性
        if (this.$el && this.$el !== document.createComment('') && this.$el.nodeType !== 8) {
          panelElement = this.$el;
        } 
        // 方法2：如果$el不可用，尝试在文档中查找
        else {
          var selectors = [
            '.panel-class',
            'component-tag',
            '.panel-root'
          ];
          
          for (var i = 0; i < selectors.length; i++) {
            panelElement = document.querySelector(selectors[i]);
            if (panelElement && panelElement.nodeType !== 8) {
              break;
            }
          }
        }
        
        if (panelElement) {
          // 确保show类被添加
          if (panelElement.classList && !panelElement.classList.contains('show')) {
            panelElement.classList.add('show');
          }
        } else {
          // 添加重试机制
          var self = this;
          setTimeout(function() {
            self.forceShowPanel(retryCount + 1);
          }, 100);
        }
      } catch (error) {
        // 添加重试机制
        var self = this;
        setTimeout(function() {
          self.forceShowPanel(retryCount + 1);
        }, 100);
      }
    });
  } catch (error) {
    // 添加重试机制
    var self = this;
    setTimeout(function() {
      self.forceShowPanel(retryCount + 1);
    }, 100);
  }
}
```

### 2.3 布局要求

- **side-panel-footer 位置**：必须放在 side-panel-container 内部，不能作为 side-panel 的直接子元素
- **flex 布局**：side-panel 使用 row 方向，side-panel-container 使用 column 方向
- **底部按钮**：使用 margin-top: auto 推到底部

### 2.4 样式标准

- **面板宽度**：统一为 400px
- **容器宽度**：统一为 380px
- **边框圆角**：统一为 16px
- **阴影效果**：显示时为 0px 10px 32px 0px rgba(51, 51, 51, 0.2)
- **边距间距**：配置区域内部使用适当的 gap 和 padding
- **暗黑模式**：支持深色主题，背景色和文本颜色自动切换
- **过渡动画**：使用 CSS3 transition 实现平滑的显示/隐藏动画
- **Flexbox 布局**：使用 Flexbox 实现响应式布局和垂直居中

## 3. 开发流程

### 3.1 组件创建

1. **创建组件文件**：在 `src/assets/js/components/` 目录下创建新组件
2. **定义模板**：**必须使用内联模板字符串**（参考 `to-svga-panel.js` 的实现方式），不要使用 HTML 模板选择器方式
3. **实现逻辑**：在组件文件中实现业务逻辑，包括 props、data、methods 等
4. **注册组件**：在 `window.MeeWoo.Components` 中注册组件，并确保在 Vue 加载完成后注册到 Vue 组件系统
5. **添加样式**：在 `panel.css` 中添加必要的样式，包括基础样式和暗黑模式样式
6. **加载组件**：在 `index.html` 中添加组件的 JS 文件加载语句，确保加载顺序正确
7. **添加拖拽支持**：确保组件支持拖拽功能，通过添加相应的 CSS 类和事件处理
8. **实现强制显示机制**：为解决模板渲染延迟问题，实现强制显示机制和重试逻辑

### 3.2 webp面板开发流程

1. **添加HTML模板**：在 `src/index.html` 中添加webp面板的HTML模板，参考frames-panel的结构
2. **创建webp-panel组件**：在 `src/assets/js/components/` 目录下创建 `webp-panel.js` 文件
3. **更新app.js**：添加webp相关的状态变量和方法
4. **更新panel-mixin.js**：在 `openRightPanel` 方法中添加对'webp'面板的支持
5. **更新底部浮层按钮**：在所有模式的底部浮层中，添加或启用"转webp"按钮
6. **实现webp导出逻辑**：使用canvas API捕获动画帧并转换为webp格式

### 3.3 输入验证实现

#### 3.3.1 HTML 属性验证

为输入框添加 `min` 和 `max` 属性，提供基本的输入提示：

```html
<input type="number" class="base-input" v-model.number="config.width" 
  @input="onWidthChange" :disabled="isExporting" 
  min="1" max="3000" />
```

#### 3.3.2 JavaScript 逻辑验证

添加输入事件处理器，使用 `Math.max` 和 `Math.min` 限制输入范围：

```javascript
onWidthChange() {
  // 验证宽度范围
  this.config.width = Math.max(1, Math.min(3000, parseInt(this.config.width) || 0))
  // 保持宽高比
  if (this.config.width > 0) {
    this.config.height = Math.round(this.config.width / this.aspectRatio)
    // 验证高度范围
    this.config.height = Math.max(1, Math.min(3000, this.config.height))
    this.$emit('config-change', this.config)
  }
}
```

## 4. 常见问题与解决方案

### 4.1 布局问题

**问题**：底部按钮布局异常，不在面板底部

**原因**：`side-panel-footer` 作为 `side-panel` 的直接子元素

**解决方案**：将 `side-panel-footer` 移动到 `side-panel-container` 内部

### 4.2 样式问题

**问题**：面板宽度和布局与其他弹窗不一致

**原因**：缺少特定面板的样式定义

**解决方案**：为特定面板添加宽度样式，确保与其他弹窗保持一致

### 4.3 输入验证问题

**问题**：用户可以输入超出范围的数字

**原因**：HTML 的 `min`/`max` 属性不能完全阻止用户输入超出范围的数字

**解决方案**：为输入框添加 JavaScript 验证逻辑，使用 `Math.max` 和 `Math.min` 限制输入值范围

### 4.4 事件处理问题

**问题**：输入框值变化时没有触发验证

**原因**：缺少 @input 事件处理器

**解决方案**：为每个输入框添加 @input 事件处理器，调用相应的验证方法

### 4.5 组件加载问题

**问题**：弹窗点击后未出现

**原因**：在 HTML 文件中遗漏了组件的 JS 文件加载语句，导致组件未被注册

**解决方案**：在 `index.html` 文件中添加组件的 JS 文件加载语句

### 4.6 面板状态管理问题

**问题**：面板打开后立即关闭

**原因**：`openRightPanel` 方法的逻辑问题：如果目标面板已经是激活状态，会关闭所有面板

**解决方案**：修改面板打开方法，使用 `Vue.nextTick` 确保状态更新后再打开面板，或者添加面板开关逻辑

### 4.7 配置生效问题

**问题**：面板尺寸和帧率设置不生效

**原因**：配置对象未正确更新，或者组件的 `config-change` 事件未正确处理

**解决方案**：确保配置变更事件正确绑定和处理，使用 `Object.assign` 正确更新配置对象

### 4.8 导出进度显示问题

**问题**：导出过程中进度条显示不流畅，导出完成后进度信息未及时清除

**原因**：进度更新频率过高，导致浏览器渲染压力大；导出完成后未及时重置进度状态

**解决方案**：优化进度更新逻辑，减少更新频率；确保导出完成后重置所有进度相关状态

### 4.9 模板渲染延迟问题

**问题**：面板尝试显示失败，已达到最大重试次数

**原因**：Vue 模板渲染延迟，导致面板元素未及时创建

**解决方案**：实现强制显示机制，使用 `Vue.nextTick` 确保模板渲染完成后再尝试显示面板，并添加重试逻辑

### 4.10 组件注册失败问题

**问题**：Vue 组件未正确注册，导致面板无法显示

**原因**：Vue 未加载完成就尝试注册组件，或者组件注册逻辑错误

**解决方案**：实现组件注册的延迟重试机制，确保 Vue 加载完成后再注册组件

### 4.11 暗黑模式样式问题

**问题**：暗黑模式下面板样式显示异常

**原因**：缺少暗黑模式的样式定义，或者样式定义不正确

**解决方案**：为面板添加暗黑模式的样式定义，确保在 `body.dark-mode` 下的样式正确显示

### 4.12 拖拽功能问题

**问题**：面板拖拽后位置异常，或者拖拽过程中动画不流畅

**原因**：拖拽逻辑错误，或者拖拽过程中未禁用过渡动画

**解决方案**：确保拖拽过程中禁用过渡动画，使用 `dragging` 类标记拖拽状态，并在拖拽结束后恢复过渡动画

### 4.13 Vue运行时版本模板编译问题（重要）

**问题**：弹窗点击后完全不显示，组件的 `$el` 是注释节点（nodeType=8）

**原因**：项目使用的是 Vue 运行时版本（`vue.min.js`），**不包含模板编译器**。当组件使用 `template: '#tpl-xxx'` 选择器方式引用 HTML 中的模板时，Vue 无法在运行时编译这个模板，导致组件渲染失败。

**问题链路**：
```
组件定义：template: '#tpl-xxx' 
       ↓
Vue运行时版本无编译器
       ↓  
模板无法编译成render函数
       ↓
组件$el变成注释节点
       ↓
DOM中没有实际元素渲染
       ↓
弹窗不显示
```

**解决方案**：**必须使用内联模板字符串方式定义模板**，而不是 HTML 模板选择器方式：

```javascript
// ❌ 错误方式：使用模板选择器（需要运行时编译器，项目不支持）
template: '#tpl-dual-channel-panel',

// ✅ 正确方式：使用内联模板字符串（Vite构建时预编译）
var template = `
  <div class="side-panel side-panel--right" :class="{'show': visible}">
    <!-- 模板内容 -->
  </div>
`;

global.MeeWoo.Components.MyPanel = {
  name: 'MyPanel',
  template: template,  // 使用模板字符串变量
  // ...
};
```

**参考实现**：`to-svga-panel.js` 使用内联模板字符串，工作正常

### 4.14 OffscreenCanvas 转 Blob API 差异问题（重要）

**问题**：双通道MP4转SVGA时报错 `dstCanvas.toBlob is not a function`

**原因**：`OffscreenCanvas` 和 `HTMLCanvasElement` 的 Blob 转换 API 不同：

| Canvas 类型 | 转 Blob 方法 | 特点 |
|-------------|-------------|------|
| `HTMLCanvasElement` | `toBlob(callback, type)` | 回调方式 |
| `OffscreenCanvas` | `convertToBlob({type})` | Promise 方式 |

**问题链路**：
```
代码尝试创建 OffscreenCanvas（性能优化）
       ↓
new OffscreenCanvas(width, height) 成功
       ↓  
调用 dstCanvas.toBlob()
       ↓
OffscreenCanvas 没有 toBlob 方法
       ↓
报错：toBlob is not a function
```

**解决方案**：通过检测 `convertToBlob` 方法是否存在来判断 Canvas 类型：

```javascript
// 转换为PNG Blob（兼容两种 Canvas 类型）
var pngBlob;
if (dstCanvas.convertToBlob) {
  // OffscreenCanvas
  pngBlob = await dstCanvas.convertToBlob({ type: 'image/png' });
} else {
  // HTMLCanvasElement
  pngBlob = await new Promise(function (resolve) {
    dstCanvas.toBlob(function (blob) {
      resolve(blob);
    }, 'image/png');
  });
}
```

**诊断方法**：查看报错信息是否包含 `toBlob is not a function`，检查代码中是否使用了 `OffscreenCanvas`

**涉及文件**：`src/assets/js/core/app.js` 中的 `extractYyevaFrames` 和 `extractYyevaFramesOptimized` 方法

## 5. 最佳实践

### 5.1 代码组织

- **组件结构**：遵循单一职责原则，每个组件只负责一个功能
- **样式分离**：将样式定义在专门的 CSS 文件中，避免内联样式
- **逻辑分离**：将业务逻辑与 UI 渲染分离，提高代码可维护性
- **文件管理**：确保每个组件的 JS 文件都在 HTML 中正确加载
- **命名空间**：使用 `window.MeeWoo` 命名空间，避免全局变量冲突
- **模块化**：使用 IIFE 模式封装组件逻辑，避免污染全局作用域

### 5.2 样式管理

- **命名规范**：使用 BEM 命名规范，确保类名语义化
- **样式复用**：使用通用样式类，避免重复定义
- **响应式设计**：确保在不同屏幕尺寸下显示正常
- **样式一致性**：为新组件添加对应的 CSS 样式，确保视觉效果与其他组件一致
- **暗黑模式**：为所有组件添加暗黑模式支持，确保在深色主题下显示正常
- **过渡动画**：使用 CSS3 transition 实现平滑的显示/隐藏动画，提升用户体验

### 5.3 输入处理

- **实时验证**：输入时立即验证，提供实时反馈
- **范围限制**：使用 JavaScript 确保输入值在合理范围内
- **类型转换**：使用 parseInt 确保输入值为数字类型
- **事件绑定**：为每个输入框添加适当的事件处理器
- **用户体验**：在输入框中添加 `min` 和 `max` 属性，提供基本的输入提示

### 5.4 性能优化

- **事件防抖**：对于频繁触发的事件，使用防抖处理
- **DOM 操作**：减少直接 DOM 操作，使用 Vue 的响应式系统
- **计算属性**：对于复杂计算，使用计算属性缓存结果
- **进度更新**：优化导出过程中的进度更新逻辑，减少更新频率
- **模板渲染**：使用 Vue 的虚拟 DOM 系统，减少直接 DOM 操作
- **资源加载**：使用 `library-loader.js` 动态加载依赖，提高初始加载速度

### 5.5 状态管理

- **Vue.nextTick**：使用 Vue.nextTick 确保状态更新后再执行 DOM 操作
- **状态重置**：确保导出完成后重置所有相关状态
- **面板开关**：实现面板的开关切换功能，提升用户体验
- **强制显示**：实现强制显示机制，解决模板渲染延迟问题
- **重试机制**：为关键操作添加重试机制，提高系统稳定性

### 5.6 错误处理

- **错误捕获**：在异步操作中添加错误捕获，避免应用崩溃
- **用户反馈**：为错误操作提供清晰的用户反馈
- **日志记录**：在关键操作中添加日志记录，便于问题排查
- **容错处理**：为可能的错误情况添加容错处理，提高系统稳定性
- **边界情况**：处理边界情况，如空值、undefined 等，避免运行时错误

## 6. 案例分析

### 6.1 frames-panel 开发案例

#### 遇到的问题

1. **布局结构问题**：side-panel-footer 位置错误，导致底部按钮布局异常
2. **输入验证问题**：用户可以输入超出范围的数字
3. **样式一致性问题**：缺少特定样式定义，导致宽度与其他弹窗不一致

#### 解决方案

1. **修复布局结构**：将 side-panel-footer 移动到 side-panel-container 内部
2. **添加输入验证**：为输入框添加 @input 事件处理器和验证逻辑
3. **添加特定样式**：为 frames-panel 添加宽度样式，确保与其他弹窗一致

### 6.2 gif-panel 参考案例

#### 成功经验

1. **输入验证实现**：使用 JavaScript 逻辑验证确保输入值在合理范围内
2. **布局结构清晰**：遵循标准布局结构，确保组件层次分明
3. **样式一致性**：与其他弹窗保持一致的样式和尺寸

### 6.3 dual-channel-panel 弹窗问题案例

#### 6.3.1 弹窗不显示问题（Vue模板编译）

**遇到的问题**：
1. 弹窗完全不显示，点击“转双通道MP4”按钮后无反应
2. `activeRightPanel` 已正确设置，但 DOM 中没有面板元素
3. 组件 `$el` 是注释节点（nodeType=8）

**根本原因**：组件使用 `template: '#tpl-xxx'` 选择器方式，但项目的 Vue 运行时版本不含模板编译器

**解决方案**：改用内联模板字符串

```javascript
// 修复前
template: '#tpl-dual-channel-panel',

// 修复后
var template = `<div class="side-panel...">...</div>`;
template: template,
```

#### 6.3.2 双通道转换视频全黑问题（Worker内存池）

**遇到的问题**：
1. SVGA导出双通道MP4时，视频尺寸、时长、声音正常，但画面全黑
2. 控制台报错：`offset is out of bounds`
3. Worker返回的 `dataLength` 与主线程期望的 `expectedLength` 不匹配

**根本原因**：Worker 内存池的 `getBuffer()` 使用 `_roundUpToPowerOfTwo()` 将缓冲区大小向上取整到2的幂次方（如 41472→65536），导致返回的数据比 Canvas ImageData 期望的大

**解决方案**：Worker 返回数据时用 `subarray()` 截取实际需要的长度

```javascript
// 修复前（dual-channel-worker.js）
return { blackBgData: blackBgData, width: dualWidth, height: height };

// 修复后
return { blackBgData: blackBgData.subarray(0, dualDataSize), width: dualWidth, height: height };
```

**诊断方法**：对比 Worker 返回的 `dataLength` 与期望值 `width*2*height*4`

#### 经验教训

1. **Vue 运行时版本限制**：`vue.min.js` 不含模板编译器，必须使用内联模板字符串
2. **Worker 内存池缓冲区**：返回数据时必须用 `subarray()` 截取实际长度
3. **诊断方法**：检查 `$el.nodeType` 是否为8；对比 Worker 返回数据长度与期望值

### 6.4 webp-panel 开发案例

#### 遇到的问题

1. **组件加载问题**：在 HTML 文件中遗漏了 `webp-panel.js` 的加载语句，导致组件未被注册
2. **面板状态管理问题**：面板打开后立即关闭
3. **样式一致性问题**：缺少 webp-panel 的宽度样式定义
4. **配置生效问题**：面板尺寸和帧率设置不生效
5. **导出进度显示问题**：导出过程中进度条显示不流畅，导出完成后进度信息未及时清除

#### 解决方案

1. **添加组件加载**：在 `index.html` 文件中添加 `webp-panel.js` 的加载语句
2. **修复面板状态管理**：修改 `openWebpPanel` 方法，使用 `Vue.nextTick` 确保状态更新后再打开面板，添加面板开关逻辑
3. **添加特定样式**：在 `panel.css` 文件中添加 webp-panel 的宽度样式
4. **修复配置生效问题**：确保 `handleWebpConfigChange` 方法正确更新 `webpConfig` 对象
5. **优化导出进度显示**：优化进度更新逻辑，减少更新频率，确保导出完成后重置所有进度相关状态

#### 成功经验

1. **组件文件管理**：确保每个组件的 JS 文件都在 HTML 中正确加载
2. **状态管理优化**：使用 `Vue.nextTick` 确保状态更新后再执行 DOM 操作
3. **样式一致性**：为新组件添加对应的 CSS 样式，确保视觉效果与其他组件一致
4. **输入验证实现**：使用 JavaScript 逻辑验证确保输入值在合理范围内
5. **用户体验提升**：实现面板的开关切换功能，优化导出进度显示

### 6.5 GIF导出卡在50%问题案例

#### 遇到的问题

1. **导出卡住**：SVGA模式下GIF导出卡在50%编码中
2. **Worker已启动**：Web Worker已成功启动，但编码过程停滞
3. **进度无波动**：编码监控显示进度几乎没波动

#### 排查过程

1. **初步分析**：怀疑是Worker通信问题或内存问题
2. **尝试方案**：
   - 增加Worker状态监控
   - 实现自动降级到单线程模式
   - 降低编码质量
   - 减少Worker数量
3. **问题定位**：所有优化方案都无效，问题不在这些方面

#### 根本原因

**过度干预第三方库的正常流程**：添加了过多的监控代码、降级逻辑、进度检测等，这些代码可能干扰了GIF.js的正常编码流程。

#### 解决方案

**简化代码，回归原始实现**：

```javascript
// ❌ 错误方式：添加过多监控和降级逻辑
var workerStatusInterval = setInterval(function() {
  // 详细的Worker状态监控...
}, 5000);

var progressStallTimeout = setTimeout(function() {
  // 自动降级逻辑...
}, 20000);

// 复杂的进度监控和事件处理...

// ✅ 正确方式：保持简洁，信任第三方库
gif.render();

// 只保留必要的事件处理
gif.on('finished', function() {
  console.log('[GIF Exporter] 编码完成');
});
```

#### 经验教训

1. **信任第三方库**：如果之前能正常运行，问题通常不在第三方库，而在于我们对它的过度干预
2. **保持简洁**：有时候最简单的解决方案就是最好的解决方案
3. **避免过度优化**：不要在问题未定位前就添加大量监控和降级逻辑
4. **回归原始**：当问题无法解决时，尝试回归到最原始的实现

#### 诊断方法

1. 检查控制台日志，确认Worker是否正常启动
2. 检查内存使用情况，排除内存问题
3. 尝试移除所有新增的监控和优化代码
4. 对比原始实现和当前实现的差异

### 6.6 Vite开发服务器Worker加载问题案例

#### 遇到的问题

1. **开发环境与生产环境表现不一致**：`npm run dev`（Vite开发模式）下GIF导出卡在50%编码中，但构建后在测试服务器正常运行
2. **Worker脚本被COEP策略阻止**：Network面板显示`gif.worker.js`请求被`ERR_BLOCKED_BY_RESPONSE`阻止
3. **配置不生效**：已在`vite.config.js`的`server.headers`中添加了`Cross-Origin-Resource-Policy`头，但Worker仍被阻止

#### 根本原因

**Vite开发服务器的`server.headers`配置对Worker脚本不生效**：Vite会对JS文件做特殊处理（模块转换、热更新等），这可能覆盖或忽略自定义headers配置。构建后的静态服务器直接提供文件，不经过这些处理，所以能正常工作。

#### 解决方案

**使用Vite中间件插件为Worker脚本添加CORS响应头**：

```javascript
// vite.config.js
export default defineConfig({
  // ...
  plugins: [
    vue(),
    // 为Worker脚本添加CORP响应头（解决COEP策略下的加载问题）
    {
      name: 'worker-cors-headers',
      configureServer(server) {
        server.middlewares.use((req, res, next) => {
          // 为Worker脚本添加必要的CORS头
          if (req.url && req.url.includes('.worker.js')) {
            res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
            res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
          }
          next();
        });
      }
    }
  ],
  // ...
});
```

#### 经验教训

1. **Vite的`server.headers`有局限性**：对于被Vite特殊处理的文件（如JS模块），`server.headers`可能不生效
2. **开发与生产环境差异**：开发服务器和生产环境的行为可能不同，需要分别测试
3. **使用中间件解决headers问题**：通过`configureServer`钩子添加中间件，可以确保特定文件获得正确的响应头
4. **COEP策略需配套CORP**：当使用`Cross-Origin-Embedder-Policy: require-corp`时，所有加载的资源（包括Worker脚本）都需要`Cross-Origin-Resource-Policy: cross-origin`响应头

#### 诊断方法

1. 检查Network面板，查看Worker脚本请求是否有`ERR_BLOCKED_BY_RESPONSE`错误
2. 对比开发环境和生产环境的表现差异
3. 检查Worker脚本的响应头是否包含`Cross-Origin-Resource-Policy`

## 7. 开发检查清单

- [ ] 遵循标准布局结构
- [ ] side-panel-footer 位置正确
- [ ] 面板宽度与其他弹窗一致
- [ ] 输入框添加了适当的验证
- [ ] 事件处理器正确绑定
- [ ] 样式定义完整，包括暗黑模式样式
- [ ] 响应式设计考虑
- [ ] 性能优化措施
- [ ] 组件 JS 文件加载语句已添加
- [ ] 面板开关逻辑已实现
- [ ] 配置变更事件已正确处理
- [ ] 导出进度显示和状态重置已实现
- [ ] 错误处理和日志记录已添加
- [ ] 拖拽功能已实现
- [ ] 强制显示机制已实现
- [ ] 组件注册逻辑正确
- [ ] **模板使用内联字符串定义**（不要用 HTML 模板选择器）
- [ ] 重试机制已添加
- [ ] 暗黑模式支持已添加
- [ ] 过渡动画已实现
- [ ] **OffscreenCanvas 使用 convertToBlob()**（不是 toBlob）

## 8. 总结

通过对MeeWoo项目侧边弹窗的开发和维护，我们积累了丰富的侧边弹窗开发经验和教训。侧边弹窗开发需要严格遵循技术规范和最佳实践，确保布局结构正确、样式一致、功能完整。

### 主要技术实现

1. **Vue组件化开发**：使用Vue 2.7.15实现组件化开发，通过props传递数据，通过事件实现组件通信
2. **CSS3过渡动画**：使用CSS3 transition实现平滑的显示/隐藏动画，提升用户体验
3. **Flexbox布局**：使用Flexbox实现响应式布局和垂直居中，确保面板在不同尺寸下显示正常
4. **拖拽功能**：实现面板的拖拽功能，允许用户自定义面板位置
5. **暗黑模式支持**：为所有面板添加暗黑模式支持，确保在深色主题下显示正常
6. **强制显示机制**：实现强制显示机制，解决模板渲染延迟问题
7. **组件注册机制**：实现组件注册的延迟重试机制，确保Vue加载完成后再注册组件
8. **模块化封装**：使用IIFE模式封装组件逻辑，避免全局变量冲突

### 主要经验教训

1. **模板定义方式**：**必须使用内联模板字符串**，不能使用 `template: '#tpl-xxx'` 选择器方式（Vue运行时版本不支持）
2. **组件文件管理**：开发新组件时，确保在HTML文件中添加对应的JS文件加载语句
3. **状态管理**：使用Vue的响应式系统时，注意异步更新的问题，必要时使用`Vue.nextTick`确保状态更新后再执行DOM操作
4. **样式一致性**：为新组件添加对应的CSS样式，确保视觉效果与其他组件一致
5. **事件处理**：确保组件的事件正确绑定和处理，特别是配置变更事件
6. **用户体验**：注意导出过程中的进度显示和状态管理，提升用户体验
7. **错误处理**：在异步操作中添加错误捕获，避免应用崩溃，为错误操作提供清晰的用户反馈
8. **暗黑模式**：为所有组件添加暗黑模式样式，确保在深色主题下显示正常
9. **拖拽功能**：确保拖拽过程中禁用过渡动画，使用`dragging`类标记拖拽状态
10. **模板编译诊断**：如弹窗不显示，检查组件`$el.nodeType`是否为8（注释节点），若是则表明模板编译失败
11. **第三方库使用**：**信任第三方库的正常流程**，避免过度干预。如果之前能正常运行，问题通常不在第三方库，而在于我们对它的过度干预。保持简洁，不要在问题未定位前就添加大量监控和降级逻辑。
12. **OffscreenCanvas API 差异**：`OffscreenCanvas` 使用 `convertToBlob()` 方法（Promise），而 `HTMLCanvasElement` 使用 `toBlob()` 方法（回调），使用前需检测 Canvas 类型

### 最佳实践总结

1. **统一组件结构**：按照项目现有的组件结构和命名规范开发新组件
2. **复用现有逻辑**：参考其他面板的实现，复用成熟的代码逻辑
3. **添加调试信息**：在关键方法中添加调试信息，便于问题排查
4. **测试验证**：开发完成后，进行全面的功能测试，确保所有功能正常工作
5. **文档记录**：记录开发过程中遇到的问题和解决方案，便于后续维护
6. **命名空间管理**：使用`window.MeeWoo`命名空间，避免全局变量冲突
7. **模块化封装**：使用IIFE模式封装组件逻辑，提高代码可维护性
8. **性能优化**：减少直接DOM操作，使用Vue的响应式系统和虚拟DOM
9. **错误处理**：为可能的错误情况添加容错处理，提高系统稳定性
10. **用户体验**：实现平滑的过渡动画，提供清晰的用户反馈
11. **第三方库集成**：信任第三方库的正常流程，避免过度干预。保持代码简洁，只在必要时添加监控和优化。如果之前能正常运行，问题通常不在第三方库。

通过本文档的指导，可以避免常见问题，提高开发效率和代码质量。随着项目的发展，本文档将不断更新和完善，积累更多开发经验，为团队提供更全面的参考资料。